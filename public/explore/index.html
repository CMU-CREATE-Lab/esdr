<!DOCTYPE html>
<html>
<head>
  <title>Explore ESDR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="UTF-8">
<style>

/*color definitions*/
:root {
  --light-sky-blue: #F1F8FF;  /* HSB 210 5% 100% */
  --medium-sky-blue: #E6F3FF; /* HSB 210 10% 100% */
  --dark-sky-blue: #D9EDFF;   /* HSB 210 15% 100% */
  --light-baby-blue: #CDE7FF; /* HSB 210 20% 100% */
  --medium-baby-blue: #B1DAFF; /* HSB 210 30% 100% */
  /*--dark-baby-blue: #7FBFFF;  /* HSB 210 50% 100% */
  --dark-baby-blue: #84BBF2;  /* HSB 210 45% 95% */

  --search-block-color: var(--light-sky-blue);
  --search-button-color: var(--light-sky-blue);
  --search-active-button-color: var(--dark-baby-blue);
  --search-groupbox-color: var(--light-baby-blue);
  --search-groupcontent-color: var(--light-sky-blue);

  --sidebar-color: var(--dark-sky-blue);
  --feed-block-color: var(--light-sky-blue);
  --channel-block-color: var(--light-sky-blue);
  
  --plot-toolbar-color: var(--light-sky-blue);
  --plot-button-color: var(--light-baby-blue);
  --toolbar-active-button-color: var(--dark-baby-blue);
  --scrubber-color: var(--medium-sky-blue);
  --scrubber-button-color: var(--dark-baby-blue);
  --plot-extension-color: var(--light-sky-blue);

}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow-y: hidden;
}

body {
  font-family: sans-serif;
}

hr {
  border: none;
  border-top: 1px solid rgba(0,0,0,0.2);
}

canvas {
  width: 100%;
  height: 100%;
  border: none;
  outline: none;
}

input[type="search"] {
  -webkit-appearance: textfield;
}

.sidebar {
  /*font-size: large;*/
  box-sizing: border-box;

  width: 0px;
  position: fixed;
  z-index: 2;
  /*use top and bottom instead of height attribute to make it fill the screen vertically*/
  top: 0;
  bottom: 0;
  left: 0;
  background-color: var(--sidebar-color);
  overflow-x: hidden;
  /*overflow-y: scroll;*/
  box-shadow: 1px 0px 1px rgba(0,0,0, 0.1);
  transition: 0.3s;
  /*padding-top: 60px;*/
}

.sidebar .search-results {
  padding-left: 0.5em;
  padding-right: 0.5em;
  /*font-size: large;*/
  overflow-y: scroll;
  height: 100%;
}


.sidebar a {
  /*padding: 8px 8px 8px 32px;*/
  text-decoration: none;
  font-size: large;
  /*background-color: #818181;*/
  display: block;
  transition: 0.3s;
}

.sidebar a:hover {
  color: #f1f1f1;
}

.floaty-search {
  position: fixed;
  /*align-items: middle;*/
  top: 0px;
  left: 0px;
  margin: 0.5em;
  z-index: 2;
  float: right;
  /*display: table-row;*/
  /*font-size: 20px;*/
  background-color: var(--search-block-color);
  color: black;
  padding: 5px 5px;
  /*border-width: 1px;*/
  /*border: 0.5px solid #777;*/
  border-radius: 3px;
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
  font-family: sans-serif;
}

.searchbar {
  font-size: large;
  display: flex;
  align-items: center;
  /*background-color: #777;*/
}

.searchbar-button {
  height: 1.5em;
  vertical-align: middle;
  margin: 0em 0.1em;
  padding: 0em 0.333em;
  font-size: inherit;
  /*background-color: inherit;*/
  /*background-color: #EEE;*/
  background-color: var(--search-button-color);
  display: flex;
  align-items: center;
  border: none;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: 0px 1px 2px rgba(0,0,0,0.15);
  text-align: center;
}

.active-searchbar-button {
  background-color: var(--search-active-button-color);
}

.in-the-middle {
  vertical-align: middle;
}

.searchbar-divider {
  display: inline-block;
  height: 1.5em;
  width: 1px;
  background-color: rgba(0,0,0,0.2);
}

.search-text {
  height: 1.5em;
  border-radius: 3px;
  border: 0px solid rgba(0,0,0,0.2);
  box-shadow: 0px 1px 2px rgba(0,0,0,0.15);
  font-size: large;
}

.search-groupbox-title {
  margin: 0.25em 0.5em;
}

.search-group-content {
  background-color: var(--search-groupcontent-color);
  border-radius: 3px;
  padding: 0.25em;
  margin: 0.25em;
  overflow: hidden;
  /*display: none;*/
  transition: 0.3s;
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1) inset;
}

.search-groupbox {
  height: 0px;
  background-color: var(--search-groupbox-color);
  border-radius: 3px;
  /*padding: 0.25em;*/
  margin: 0.5em 0.1em;
  overflow: hidden;
  /*display: none;*/
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
  transition: 0.3s;
}

.search-input-row {
  display: flex;
  align-items: center;
}

.search-progress-block {
  /*padding-top: 0.5em;*/
  padding-bottom: 0px;
  height: 0px;
  overflow: hidden;
  transition: 0.3s;
  background-color: transparent;
}

.search-result-feed-block {
  font-size: small;
  font-weight: bold;
  padding: 0.1em 0.25em;
  margin: 0.5em 0em;
  background-color: var(--feed-block-color);
  /*box-shadow: 1px 1px 2px rgba(0,0,0,0.1);*/
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
  border-radius: 3px;
}
.search-result-channel-block {
  background-color: var(--channel-block-color);
  font-size: smaller;
  font-weight: normal;
}

.graphs {
  height: 0px;
  overflow-y: scroll;
  /*display: none;*/
  transition: 0.3s;
}

.googlemap {
  /*display: inline-block;*/
  /*position: absolute;*/
  /*top: 0px;*/
  height: 60%;
  /*width:100%;*/
  /*min-height: 100%;*/
  transition: 0.3s;
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
}

.map-overlay-static {
  position: absolute;
  z-index: -1;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  background-color: rgba(255,255,0,0.3);
  transition: margin-left 0.3s;
  pointer-events: none;
}

.plots-container {
  height: 40%;
  position: absolute;
  bottom: 0px;
  box-shadow: 0px -1px 1px rgba(0,0,0,0.1);
  overflow-y: hidden;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  transition: 0.3s;
  /*z-index: 1;*/
}

.plots-list {
  /*height: calc(100%-2em);*/
  /*box-shadow: 0px 0px 2px rgba(0,0,0,0.1);*/
  flex-grow: 1;
/*  position: relative;
  top: 0px;
  bottom: 0px;
*/  overflow-y: scroll;
  overflow-x: hidden;
  transition: 0.3s;
}

.plots-toolbar {
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
  display: flex;
  flex-shrink: 0;
  align-items: center;
  font-size: large;
  background-color: var(--plot-toolbar-color);
  padding-left: 0.25em;
  padding-right: 0.52em;
  padding-bottom: 0.25em;
  padding-top: 0.25em;
}

.toolbar-spacer {
  flex-shrink: 3;
  flex-grow: 1;
  min-width: 0px;
  width: 1em;
}

.toolbar-group-spacer {
  flex-shrink: 3;
  flex-grow: 1;
  min-width: 0px;
  max-width: 2em;
  width: 1em;
}


.plots-date-scrubber {
  -webkit-appearance: none;
  height: 1em;
  width: 100%;
  min-width: 4em;
  border-radius: 3px;
  margin: 0.5em 0.25em;
  outline: none;
  background: var(--scrubber-color);
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1) inset;

}
.plots-date-scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 1.5em;
  width: 2em;
  border-radius: 3px;
  cursor: pointer;
  background: var(--scrubber-button-color);
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1), 0px 2px 2px rgba(255,255,255,0.1) inset, 0px -2px 2px rgba(0,0,0,0.05) inset;
}
.plots-date-scrubber::-moz-range-thumb {
  height: 1.5em;
  width: 2em;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  background: var(--scrubber-button-color);
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1), 0px 2px 2px rgba(255,255,255,0.1) inset, 0px -2px 2px rgba(0,0,0,0.05) inset;
}

.plots-zoom-scrubber {
  -webkit-appearance: none;
  height: 1em;
  width: 100%;
  min-width: 4em;
  margin: 0.5em 0.25em;
  border-radius: 0.5em;
  outline: none;
  background: var(--scrubber-color);
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1) inset;
}
.plots-zoom-scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 1.5em;
  width: 1.5em;
  border-radius: 50%;
  cursor: pointer;
  background: var(--scrubber-button-color);
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1), 0px 2px 2px rgba(255,255,255,0.1) inset, 0px -2px 2px rgba(0,0,0,0.05) inset;
}
.plots-zoom-scrubber::-moz-range-thumb {
  height: 1.5em;
  width: 1.5em;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  background: var(--scrubber-button-color);
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1), 0px 2px 2px rgba(255,255,255,0.1) inset, 0px -2px 2px rgba(0,0,0,0.05) inset;
}

.date-axis {
  /*box-sizing: border-box;*/
  height: calc(2em-0.0px);
  width: calc(100%-2em);
}

.plot-options-row {
  display: flex;
  align-items: center;
  height: 0px;
  transition: 0.3s;
  overflow-y: hidden;
  overflow-x: hidden;
}

.plot-corner {
  width: 2em;
  height: calc(2em - 0.0px);
  padding: 0px;
  margin: 0px;
  box-sizing: border-box;
/*  border-bottom: 0.5px solid black;
  border-left: 0.5px solid black;
*/  /*background: #770;*/
  flex-shrink: 0;
  flex-grow: 0;
}
.plot-extension {
  width: 0px;
  /*height: 2em;*/
  padding: 0px;
  margin: 0px;
  box-sizing: border-box;
  border-left: 0.5px solid black;
  flex-shrink: 0;
  flex-grow: 0;
/*  display: flex;
  align-items: center;
*/  white-space: nowrap;
  overflow-x: hidden;
  overflow-y: hidden;
  background-color: var(--plot-extension-color);
}

.plot-extension-box {
  display: flex; 
  flex-direction: row; 
  align-items: stretch; 
  flex-grow: 0; 
  flex-shrink: 0; 
  overflow-y: hidden;
}

.plots-toolbar-button {
  font-size: inherit;
  vertical-align: middle;
  flex-shrink: 0;
  flex-grow: 0;
  align-items: center;
  display: flex;
  flex-direction: row;

  background-color: transparent;
  /*background-color: #e0e7f7;*/

  border-radius: 3px;
  /*display: inline;*/
  /*color: white;*/
  /*padding: 10px 15px;*/
  border: none;
  cursor: pointer;
/*  margin-left: 0.25em;
  margin-right: 0.25em;
*/
  margin:0;
  padding: 0em 0.5em;
  height: 1.5em;
  /*height: inherit;*/
  box-sizing: border-box;
  /*content-fit: cover;*/
/*  padding: 0px;
  margin: 0px;
*/
  text-align: center;
}

.plots-toolbar-button:disabled {
  opacity: 0.5;
}

.active-toolbar-button {
  background-color: var(--toolbar-active-button-color);
}

.plots-shadow-group {
  display: flex;
  flex-shrink: 1;
  align-items: center;
  box-shadow: 0px 1px 2px rgba(0,0,0,0.15);
  background-color: var(--plot-button-color);
  margin: 0.0em 0.25em;
  padding: 0.0em 0em;
  border-radius: 3px;
}

.plots-toolbar-group-left {
  margin-right: 0em;
  border: none;
  border-radius: 3px 0px 0px 3px;
  /*border-right: 1px solid gray;*/
}
.plots-toolbar-group-right {
  margin-left: 0em;
  border-radius: 0px 3px 3px 0px;
}
.plots-toolbar-group-center {
  margin-right: 0em;
  margin-left: 0em;
  border-radius: 0px;
}

.plots-toolbar-group-divider {
  padding-right: 0em;
  padding-left: 0em;
  margin-left: 0px;
  margin-right: 0px;
  border-radius: 0px;
/*  padding-top: 4px;
  padding-bottom: 4px;
*/
  /*width: 0px;*/
  overflow-x: visible;
}

.plots-toolbar-group-divider-content {
  vertical-align: middle;
  height: 1em;
  width: 1px;
  padding: 0;
  margin: 0;
  /*left: -0.5px;*/
  background-color: rgba(0,0,0,0.2);
}

.button-icon {
  font-size: inherit;
  height: 1em; 
  /*width: 0.777778em;*/
  vertical-align: middle;
  cursor: pointer;
  margin-left: 0px;
  margin-right: 0px;
  /*object-fit: contain;*/
}

#main {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  box-sizing: border-box;
  transition: margin-left .3s;
  /*padding: 16px;*/
  height: 100%;
  overflow-y: hidden;
}



/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */
@media screen and (max-height: 450px) {
  /*.sidebar {padding-top: 15px;}*/
  /*.sidebar a {font-size: 18px;}*/
}
</style>
</head>
<body>

<div id="searchSidebar" class="sidebar">
    <div id="searchResultsList" class="search-results"></div>
</div>

<div id="searchBlock" class="floaty-search">
  <div class="searchbar">
  <!-- <button class="searchbar-button" onclick="toggleSidebar()">☰</button> -->
  <button class="searchbar-button" id="showSearchResultsButton" onclick="explorer.toggleSidebar()"><img src="hamburger.svg" class="button-icon"></img></button>
  <!-- <div class="searchbar-divider"></div> -->
  <button class="searchbar-button" id="showDataFiltersButton" onclick="explorer.toggleFilters()"><img src="filter.svg" class="button-icon"></img></button>
  <!-- <div class="searchbar-divider"></div> -->
  <button class="searchbar-button" id="showSettingsButton" onclick="explorer.toggleSettings()"><img src="settings.svg" class="button-icon"></img></button>
  <!-- <div class="searchbar-divider"></div> -->
  <input type="search" id="sensorSearchField" class="search-text" placeholder="search sensor feeds">
  <!-- <button class="searchbar-button" onclick="doSensorSearch()"><img src="loupe.svg" class="button-icon"></img></button> -->
  <!-- <div class="searchbar-divider"></div> -->
  <button class="searchbar-button" onclick="showHelp()">?</button>
  </div>
  <div id="filtersBlock" class="search-groupbox">
    <div class="search-groupbox-title">Data Filters</div>
    <div class="search-group-content">
      <div><input type="checkbox" id="recentOnlyCheckbox" name="checkbox-recentOnly" title="only show sensors with new data from the last 30 days" class="in-the-middle" /><label for="recentOnlyCheckbox" class="in-the-middle"><span class="in-the-middle">Data in Last 30 Days</span></label></div>
      <div><input type="checkbox" id="mapOnlyCheckbox" name="checkbox-mapOnly" title="only show sensors that are on the map area" class="in-the-middle" /><label for="mapOnlyCheckbox" class="in-the-middle"><span class="in-the-middle">On Map</span></label></div>
    </div>
  </div>
  <div id="settingsBlock" class="search-groupbox">
    <div class="search-groupbox-title">Settings</div>
    <div class="search-group-content">
      <div class="search-input-row"><input type="checkbox" id="showSparklinesCheckbox" name="checkbox-showSparklines" title="Show Sparklines" /><label for="showSparklinesCheckbox">Sparklines on Map</label></div>

    </div>
  </div>
  <div id="progressBlock" class="search-progress-block">
    <div id="searchProgressText"></div>
  </div>
</div>



<div id="main">
  <div id="googlemap" class="googlemap" style="height:60%"></div>
  <!-- <div id="mapOverlayStatic" class="map-overlay-static"></div> -->
  <!-- this insanity with the iframe here is because we use them to capture resize events of the plots pane, so that the grapher plots are correctly resized when the page layout changes -->
  <iframe id="plotWidthIframe" style="height:0px; border:none;"></iframe>
  <div id="plots" class="plots-container" style="height:40%">
    <div id="plotsToolbar" class="plots-toolbar">
      <div class="toolbar-spacer" style="flex-grow: 1;"></div>
      <div class="plots-shadow-group">
        <button class="plots-toolbar-button plots-toolbar-group-left" onclick="explorer.moveTimelineByFactorAnimated(-0.25)" style="padding-right: 0.25em;">
          <img src="goleft.svg" class="button-icon"></img>
        </button>
        <div class="plots-toolbar-button plots-toolbar-group-center" style="padding-left: 0;padding-right: 0; flex-shrink: 1; flex-basis: 10em;">
          <input type="range" min="-100" max="100" value="0" class="plots-date-scrubber" id="plotsDateScrubber" />
        </div>
        <button class="plots-toolbar-button plots-toolbar-group-right" onclick="explorer.moveTimelineByFactorAnimated(0.25)" style="padding-left: 0.25em;">
          <img src="goright.svg" class="button-icon"></img>
        </button>
        <button class="plots-toolbar-button plots-toolbar-group-divider"><div class="plots-toolbar-group-divider-content"></div></button>
        <button class="plots-toolbar-button" onclick="explorer.moveTimelineTo(Date.now() * 0.001, 0.9)"><img src="gonow.svg" class="button-icon"></img></button>
      </div>
      <div class="toolbar-group-spacer"></div>
      <div class="plots-shadow-group">
        <button class="plots-toolbar-button plots-toolbar-group-left" onclick="explorer.zoomTimelineByFactorAnimated(1.4142135624)" style="padding-right: 0.25em;">
          <img src="minus.svg" class="button-icon"></img>
        </button>
        <div class="plots-toolbar-button plots-toolbar-group-center" style="padding-left: 0;padding-right: 0;  flex-shrink: 1; flex-basis: 10em;">
          <input type="range" min="-100" max="100" value="0" class="plots-zoom-scrubber" id="plotsZoomScrubber" />
        </div>
        <button class="plots-toolbar-button plots-toolbar-group-right" onclick="explorer.zoomTimelineByFactorAnimated(0.7071067812)" style="padding-left: 0.25em;">
          <img src="plus.svg" class="button-icon"></img>
        </button>
        <button class="plots-toolbar-button plots-toolbar-group-divider"><div class="plots-toolbar-group-divider-content"></div></button>
        <button class="plots-toolbar-button plots-toolbar-group-left" onclick="explorer.zoomTimelineToSize(24*60*60)">day</button>
        <button class="plots-toolbar-button plots-toolbar-group-divider"><div class="plots-toolbar-group-divider-content"></div></button>
        <button class="plots-toolbar-button plots-toolbar-group-center" onclick="explorer.zoomTimelineToSize(31*24*60*60)">month</button>
        <button class="plots-toolbar-button plots-toolbar-group-divider"><div class="plots-toolbar-group-divider-content"></div></button>
        <button class="plots-toolbar-button plots-toolbar-group-right" onclick="explorer.zoomTimelineToSize(365*24*60*60)">year</button>
      </div>
      <div class="toolbar-group-spacer"></div>
      <div class="plots-shadow-group">
        <button id="decreasePlotAreaHeightButton" class="plots-toolbar-button plots-toolbar-group-left" onclick="explorer.decreasePlotAreaHeight()"><img src="ylower.svg" class="button-icon"></img></button>
        <button class="plots-toolbar-button plots-toolbar-group-divider"><div class="plots-toolbar-group-divider-content"></div></button>
        <button id="increasePlotAreaHeightButton" class="plots-toolbar-button plots-toolbar-group-right" onclick="explorer.increasePlotAreaHeight()"><img src="yraise.svg" class="button-icon"></img></button>
      </div>
        <!-- <div class="toolbar-spacer"></div> -->
      <div class="plots-shadow-group">
        <button id="decreasePlotHeightButton" class="plots-toolbar-button plots-toolbar-group-left" onclick="explorer.decreasePlotHeight()"><img src="yshrink.svg" class="button-icon"></img></button>
        <button class="plots-toolbar-button plots-toolbar-group-divider"><div class="plots-toolbar-group-divider-content"></div></button>
        <button id="increasePlotHeightButton" class="plots-toolbar-button plots-toolbar-group-right" onclick="explorer.increasePlotHeight()"><img src="ygrow.svg" class="button-icon"></img></button>
      </div>
      <div class="toolbar-group-spacer"></div>
      <div class="plots-shadow-group">
        <button id="showDataDownloadsButton" class="plots-toolbar-button" onclick="explorer.toggleDataDownloads()"><img src="download.svg" class="button-icon"></img></button>
      </div>
    </div>
    <div id="plotOptions" class="plot-options-row">
      here be options
    </div>
    <div class="plot-extension-box">
      <div id="date_axis" class="date-axis"></div>
      <div id="plotCorner" class="plot-corner">
        <div style="box-sizing: border-box; border-left: 0.5px solid black; border-bottom: 0.5px solid black; width: 100%; height: 100%;"></div>
      </div>
      <div id="plotCornerExtension" class="plot-extension">
        <div style="box-sizing: border-box; padding: 0.0em 0.25em; height: 2em; display: inline-flex; align-items: center; border-bottom: 0.5px solid black;">
          <label for="exportTimezoneSelector" style="font-size: small;">Download Time Format:</label>
  <!--         <select id="exportTimezoneSelector">
            <option value=local>Local Time</option>
            <option value="utc">UTC</option>
            <option value="epoch">Unix Epoch</option>
            <option disabled class="selector-separator"></option>
          </select>
   -->
          <input type="text" name="timezoneInput" id="timezoneSelectorInput" list="timezoneDatalist" placeholder="Current Browser Timezone" autocomplete="off" onchange="explorer.downloadTimezoneChanged(event)" />
          <datalist id="timezoneDatalist">
            <option value="Current Browser Timezone" />
            <option value="UTC" />
            <option value="UNIX Epoch Timestamp" />
          </datalist>
        </div>
      </div>
    </div>
    <div style="display: flex; flex-direction: row; flex-grow: 1; flex-shrink: 1; overflow-y: scroll">
      <iframe id="plotHeightIframe" style="height:100%; width:0px; border:none; float:left;"></iframe>
      <div id="plotList" class="plots-list"></div>
    </div>
  </div>
</div>

<script src="esdrFeeds.js"></script>
<script src="embeddedTilePlotter.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCjVZHnH5L8ty50awHChDGdtJ5ZHqCFc-Y"></script>
<script src="mapOverlay.js"></script>

<script src="../lib/jquery/jquery-1.11.1.min.js" type="text/javascript"></script>
<script src="../lib/jquery-mousewheel/jquery.mousewheel.min.js"></script>
<script src="../lib/superagent/superagent.js" type="text/javascript"></script>
<script src="../lib/createlab-grapher/grapher.min.js"></script>
<!-- <script src="../lib/bodytrack-grapher/org/bodytrack/grapher/grapher2.nocache.js" type="text/javascript"></script> -->
<script src="../lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>
  
  <!-- <script src="https://d3js.org/d3.v4.js"></script> -->

<!-- timezone selection support -->
<script src="https://momentjs.com/downloads/moment.min.js" type="text/javascript"></script>
<script src="https://momentjs.com/downloads/moment-timezone-with-data-10-year-range.min.js" type="text/javascript"></script>


<script>

let gMap // google map instance
let esdr = new ESDR() // interface to ESDR data
let explorer = {
  statusInfo: {
    numFeedsReceived: 0,
    numSearchResults: 0,
  },
  results: [],
  plots: new Map(),
  showFilters: true,
  showResults: true,
  showSettings: true,
  showSparklines: true,
  plotAreaHeightPercent: 40,
  minPlotAreaHeightPercent: 20,
  maxPlotAreaHeightPercent: 80,
  plotHeight: 5,
  minPlotHeight: 2,
  maxPlotHeight: 20,
  lineStyle: {
    "styles": [
      // {
      //   "type": "bar",
      //   "stripPosition": "center",
      //   "stripWidthSecs": 30,
      //   "rangedColors": "rgba(210,210,210,.8); 10;rgba(185,185,185,.8); 20;rgba(160,160,160,.8); 30;rgba(135,135,135,.8); 40;rgba(110,110,110,.8); 50;rgba(110,110,110,.8);60;rgba(85,85,85,.8);70;rgba(70,70,70,.8);80;rgba(50,50,50,.8)"
      // },
      {
        "type": "line",
        "lineWidth": 1,
        "show": true,
        "color": "rgba(60,60,60, .8)"
      },
      {
        "type": "circle",
        "radius": 1,
        "lineWidth": 1,
        "show": true,
        "color": "#000000",
        "fill": false
      },
    ],
    "highlight": {
      "lineWidth": 2,
      "styles": [{
          "show": true,
          "type": "lollipop",
          "color": "green",
          "radius": 0,
          "lineWidth": 1,
          "fill": false
        },
        {
          "type": "circle",
          "radius": 3,
          "lineWidth": 0.5,
          "show": true,
          "color": "#ff0000",
          "fill": true
        },
        {
          "show": true,
          "type": "value",
          "fillColor": "#000000",
          "marginWidth": 10,
          "font": "9pt Helvetica,Arial,Verdana,sans-serif",
          "verticalOffset": 7
        }
      ]
    }
  },

}

function initMap() {
  // parse the url hash part
  parseUrlParams()
  // execute params
  if (explorer.showResults)
    showSearchResults()

  // FIXME: showSearchFilters() with a small delay, otherwise the margin computation gets confused. maybe this could be done with less hackery?
  if (explorer.showFilters)
    setTimeout(explorer.showSearchFilters, 300)

  if (explorer.showSettings)
    setTimeout(explorer.showSearchSettings, 600)

  let mapdiv = document.getElementById('googlemap');
  gMap = new google.maps.Map(
    document.getElementById('googlemap'),
    {
      zoom: parseInt(explorer.zoom) || 5,
      center: explorer.center || new google.maps.LatLng(49.35720091782239, -92.91969375610346*0.0),

      streetViewControl: false,
      fullscreenControl: false,

      mapTypeControlOptions: {
        position: google.maps.ControlPosition.TOP_RIGHT,
      },

      styles: [
        {
          "featureType": "poi",
          "elementType": "labels.text",
          "stylers": [{
            "visibility": "off"
          }]
        },
        {
          "featureType": "road",
          "elementType": "labels.icon",
          "stylers": [{
            "visibility": "off"
          }]
        }, 
        {
          "featureType": "road",
          "elementType": "geometry.stroke",
          "stylers": [{
            "visibility": "off"
          }]
        }, 
        {
          "featureType": "road.highway",
          "elementType": "geometry.fill",
          "stylers": [{
            "color": "#bbbbbb"
          }]
        }, 
        {
          "featureType": "road"
        }, 
        {
          "featureType": "road",
          "elementType": "labels.text.fill",
          "stylers": [{
            "color": "#888888"
          }]
        }, {
          "featureType": "administrative",
          "elementType": "labels.text.fill",
          "stylers": [{
            "color": "#606060"
          }]
        },
        {
          "featureType": "administrative.locality",
          "elementType": "labels.icon",
          "stylers": [{
            "visibility": "off"
          }]
        },
        {
          "featureType": "road",
          "elementType": "geometry",
          "stylers": [{
              "lightness": 100
            },
            {
              "visibility": "simplified"
            }
          ]
        },
        {
          "featureType": "water",
          "elementType": "geometry",
          "stylers": [{
              "visibility": "on"
            },
            {
              "color": "#C6E2FF"
            }
          ]
        },
        {
          "featureType": "poi",
          "elementType": "geometry.fill",
          "stylers": [{
            "color": "#C5E3BF"
          }]
        },
        {
          "featureType": "road",
          "elementType": "geometry.fill",
          "stylers": [{
            "color": "#D1D1B8"
          }]
        }
      ],
    }
  );

  explorer.mapOverlay = new MapOverlay(gMap, mapdiv)


  google.maps.event.addListener(gMap, 'bounds_changed', function() {
    // console.log(`bounds_changed event to ${map.getBounds()}`);


    if (explorer.deferredMapBoundsUpdateTimer)
      clearTimeout(explorer.deferredMapBoundsUpdateTimer)

    explorer.deferredMapBoundsUpdateTimer = setTimeout(explorer.deferredMapBoundsUpdateCallback, 500, gMap)

  })

  google.maps.event.addListener(gMap, 'mousemove', function(event) {
    let feedIds = explorer.mapOverlay.highlightMarkersAt(event.pixel, true)
    this.setOptions({
      draggableCursor: (feedIds.length > 0 ? 'default' :  null)
    });

    explorer.highlightPlotsForFeeds(feedIds)

  })

  google.maps.event.addListener(gMap, 'click', function(event) {
    if (!explorer.mapOverlay.markers)
      return

    explorer.mapOverlay.highlightMarkersAt(event.pixel, true)


    let div = document.createElement("div")
    // div.setAttribute("class", "search-result-channel-block")

    let highlightedFeedIds = Array.from(explorer.mapOverlay.markers.highlightedFeeds).sort()

    for (let feedId of highlightedFeedIds) {
      let feed = esdr.feeds.get(feedId)
      let feedDiv = searchResultsDivForFeed(feedId)
      if (feed && feed.channelBounds && feed.channelBounds.channels)
      {
        let channelDivs = []
        for (let channelName in feed.channelBounds.channels) {
          let chdiv = searchResultsDivForChannel(feedId, channelName, "infoWindow")
          channelDivs.push(chdiv)
        }

        for (let chdiv of channelDivs) {
          feedDiv.appendChild(chdiv)
        }
      }
      div.appendChild(feedDiv)

    }

    if (this.infoWindow)
      this.infoWindow.close()

    if (highlightedFeedIds.length > 0) {
      let eventGeoCoords = explorer.mapOverlay.viewPixelToGeoCoords(event.pixel)
      this.infoWindow = new google.maps.InfoWindow({
        content: div,
        position: eventGeoCoords,
      })
      this.infoWindow.open(gMap)
    }
  })

  let bounds = gMap.getBounds()
  explorer.mapBounds = bounds
  esdr.updateQuery({mapBounds: bounds})

  // inform mapOverlay of selected items
  for (channelId of esdr.selectedChannelIds) {
    let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    explorer.mapOverlay.selectFeed(feedId, true)
  }


  // install search response events
  // onchange is when user presses enter
  let searchInput = document.getElementById("sensorSearchField")
  searchInput.addEventListener("change", event => {
    let searchText = event.target.value
    // console.log(searchText)
    esdr.updateQuery({text: searchText})

    // if a delayed update was pending, cancel it
    if (explorer.searchUpdateTimer) {
      clearTimeout(explorer.searchUpdateTimer)
      explorer.searchUpdateTimer = undefined
    }

    updateUrlHash()
  })
  // oninput happens every time a character is entered, so let's add a delay
  searchInput.addEventListener("input", event => {
    let searchText = event.target.value

    if (explorer.searchUpdateTimer) {
      clearTimeout(explorer.searchUpdateTimer)
    }

    explorer.searchUpdateTimer = setTimeout(timestamp => {
      esdr.updateQuery({text: searchText})

      updateUrlHash()

      explorer.searchUpdateTimer = undefined
    }, 500)

  })

  let recentOnlyCheckbox = document.getElementById("recentOnlyCheckbox")
  recentOnlyCheckbox.addEventListener("change", event => {
    let checked = event.target.checked
    esdr.updateQuery({recentOnly: checked})

    updateUrlHash()
  })
  let mapOnlyCheckbox = document.getElementById("mapOnlyCheckbox")
  mapOnlyCheckbox.addEventListener("change", event => {
    let checked = event.target.checked
    esdr.updateQuery({mapOnly: checked})

    updateUrlHash()
  })

  // install search results callback
  esdr.searchCallback = (searchResults, isAppendUpdate) => processNewSearchResults(searchResults, isAppendUpdate)
  // start loading feed data
  esdr.loadFeeds(explorer.esdrFeedsReceived)

  esdr.channelDataUpdateCallback = (feedId, channelName) => {
    let channelId = `${feedId}.${channelName}`
    // console.log(`channelDataUpdateCallback(${channelId}`)
    // no need to do fit with autoscaling enabled
    // let plotNumber = explorer.plots.get(channelId)
    // if (plotNumber)
    //   explorer.fitPlotYAxisToData(plotNumber)
  }


  // install scroll listener
  let searchResultsList = document.getElementById("searchResultsList")
  searchResultsList.addEventListener('scroll', () => {
    appendSearchResultsListIfNeeded()
  })
}

explorer.deferredMapBoundsUpdateCallback = function(map) {
  // console.log("deferredMapBoundsUpdateCallback")
  explorer.deferredMapBoundsUpdateTimer = undefined

  let mapBounds = gMap.getBounds()

  // need this elaborate comparison because simple equality tests dont work to determine if the bounds actually changed:(
  // if the bounds didn't really change, then we can just do nothing
  if (ESDR.areMapBoundsEqual(explorer.prevMapBounds, mapBounds))
  if (explorer.prevMapBounds && (mapBounds.getSouthWest().lng() == explorer.prevMapBounds.getSouthWest().lng()) && (mapBounds.getNorthEast().lng() == explorer.prevMapBounds.getNorthEast().lng()) && (mapBounds.getSouthWest().lat() == explorer.prevMapBounds.getSouthWest().lat()) && (mapBounds.getNorthEast().lat() == explorer.prevMapBounds.getNorthEast().lat())) {
    return
  }

  // console.log(`bounds_changed ${mapBounds}`)

  explorer.prevMapBounds = mapBounds

  // console.log(`deferredMapBoundsUpdateCallback for real ${mapBounds}`)

  // update the persistent states for map bounds
  let center = map.getCenter()
  explorer.center = center
  let zoom = map.getZoom()
  explorer.zoom = zoom
  explorer.mapBounds = mapBounds
  esdr.updateQuery({mapBounds: mapBounds})

  updateUrlHash()
}


function parseUrlParams() {
  let browserParams = new URLSearchParams(window.location.hash.slice(1))

  // selected channels for plotting
  if (browserParams.has("channels")) {
    // TODO: add support for pipe separator old-style URLs?
    let channelIds = browserParams.get("channels").split(",").filter((word) => word.length > 0)
    for (channelId of channelIds) {
      // select channel and add plot
      esdr.selectChannelWithId(channelId, true)
      // let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
      // let channelName = channelId.slice(channelId.indexOf(".")+1)
      // explorer.addPlot(feedId, channelName)
    }
  }

  // grapher time limits and cursor
  if (browserParams.has("time")) {
    let times = browserParams.get("time").split(",")
    let startTime = parseFloat(times[0])
    if (isFinite(startTime))
      explorer.startTime = startTime
    let endTime = parseFloat(times[1])
    if (isFinite(endTime))
      explorer.endTime = endTime
  }
  if (browserParams.has("plotAreaHeight")) {
    let height = parseFloat(browserParams.get("plotAreaHeight"))
    if (isFinite(height)) {
      explorer.setPlotAreaHeight(height)
    }
  }

  if (browserParams.has("plotHeight")) {
    let height = parseFloat(browserParams.get("plotHeight"))
    if (isFinite(height)) {
      explorer.plotHeight = Math.min(Math.max(height, explorer.minPlotHeight), explorer.maxPlotHeight)
      explorer.setPlotsToHeight(explorer.plotHeight*explorer.plotBaseSize())
    }
  }

  if (browserParams.has("cursor")) {
    let cursorTime = parseFloat(browserParams.get("cursor"))
    if (isFinite(cursorTime))
      explorer.cursorTime = cursorTime
  }

  // map params
  if (browserParams.has("zoom")) {
    explorer.zoom = parseFloat(browserParams.get("zoom"))
  }

  if (browserParams.has("center")) {
    let latlon = browserParams.get("center").split(",")
    explorer.center = new google.maps.LatLng(latlon[0], latlon[1])
  }

  // search
  if (browserParams.has("search")) {
    let searchText = browserParams.get("search")
    let searchInput = document.getElementById("sensorSearchField")
    searchInput.value = searchText
    esdr.updateQuery({text: searchText})
  }
  if (browserParams.has("recentOnly")) {
    let recentOnly = browserParams.get("recentOnly") == "true"
    let recentOnlyCheckbox = document.getElementById("recentOnlyCheckbox")
    recentOnlyCheckbox.checked = recentOnly
    esdr.updateQuery({recentOnly: recentOnly})
  }
  if (browserParams.has("mapOnly")) {
    let mapOnly = browserParams.get("mapOnly") == "true"
    let mapOnlyCheckbox = document.getElementById("mapOnlyCheckbox")
    mapOnlyCheckbox.checked = mapOnly
    esdr.updateQuery({mapOnly: mapOnly})
  }

  // new params for display state
  if (browserParams.has("showFilters")) {
    explorer.showFilters = browserParams.get("showFilters") == "true"
  }
  if (browserParams.has("showSettings")) {
    explorer.showSettings = browserParams.get("showSettings") == "true"
  }
  if (browserParams.has("showResults")) {
    explorer.showResults = browserParams.get("showResults") == "true"
  }

  // on-map sparklines
  if (browserParams.has("showSparklines")) {
    explorer.showSparklines = browserParams.get("showSparklines") == "true"
    let sparklinesCheckbox = document.getElementById("showSparklinesCheckbox")
    sparklinesCheckbox.checked = explorer.showSparklines
  }


}

function createUrlParams() {
  let browserParams = new URLSearchParams()

  if (esdr.selectedChannelIds.length > 0) {
    browserParams.set("channels", esdr.selectedChannelIds.join(','))
  }
  if (explorer.startTime || explorer.endTime) {
    browserParams.set("time", [explorer.startTime.toFixed(3), explorer.endTime.toFixed(3)].join(','))
  }
  if (explorer.cursorTime) {
    browserParams.set("cursor", explorer.cursorTime.toFixed(3))
  }
  if (explorer.plotHeight) {
    browserParams.set("plotHeight", explorer.plotHeight.toFixed(3))
  }
  if (explorer.plotAreaHeightPercent) {
    browserParams.set("plotAreaHeight", explorer.plotAreaHeightPercent.toFixed(3))
  }

  if (explorer.showSparklines) {
    browserParams.set("showSparklines", "true")
  }

  // explicitly set both showFilters and showResults because the default is to show
  if (explorer.showFilters) {
    browserParams.set("showFilters", explorer.showFilters ? "true" : "false")
  }
  if (explorer.showSettings) {
    browserParams.set("showSettings", explorer.showSettings ? "true" : "false")
  }
  if (explorer.showResults) {
    browserParams.set("showResults", explorer.showResults ? "true" : "false")
  }
  if (explorer.showSparklines) {
    browserParams.set("showSparklines", explorer.showSparklines ? "true" : "false")
  }
  if (explorer.center) {
    browserParams.set("center", `${explorer.center.lat()},${explorer.center.lng()}`)
  }
  if (explorer.zoom) {
    browserParams.set("zoom", `${explorer.zoom}`)
  }
  if (esdr.searchQuery.recentOnly) {
    browserParams.set("recentOnly", `${esdr.searchQuery.recentOnly}`)
  }
  if (esdr.searchQuery.mapOnly) {
    browserParams.set("mapOnly", `${esdr.searchQuery.mapOnly}`)
  }

  if (esdr.searchQuery.text) {
    browserParams.set("search", esdr.searchQuery.text)
  }

  return browserParams
}

function updateUrlHash() {
  let params = createUrlParams()
  // as URLSearchParams escapes commas, finally replace the escaped commas with human readable commas again
  window.location.hash = `#${params.toString().replace(/%2C/gi,',')}`
}




function adjustSidebarTopPadding(adjustment) {
  let searchBlock = document.getElementById("searchBlock")
  let searchStyle = window.getComputedStyle(searchBlock)
  let sidebar = document.getElementById("searchSidebar")

  sidebar.style.paddingTop = `calc(${searchBlock.offsetHeight}px + ${searchStyle.marginTop} + ${searchStyle.marginBottom} + (${adjustment}))`

}


function showSearchResults() {
  let sidebar = document.getElementById("searchSidebar")
  if (!sidebar.style.width || sidebar.style.marginLeft !== "0px") {
    explorer.toggleSidebar()
  }
}

explorer.toggleSidebar = function() {
  let searchBlock = document.getElementById("searchBlock")
  let searchStyle = window.getComputedStyle(searchBlock)
  let sidebar = document.getElementById("searchSidebar")
  let mainBlock = document.getElementById("main")

  if (!sidebar.style.width || sidebar.style.marginLeft !== "0px") {
    // set the widths to show sidebar
    let blockWidth = searchBlock.scrollWidth + 'px'
    let margin = `${searchStyle.marginLeft} + ${searchStyle.marginRight}`
    let width = `${margin} + ${blockWidth}`
    sidebar.style.width = `calc(${width})`
    sidebar.style.left = `0px`
    sidebar.style.marginLeft = `0px`
    mainBlock.style.marginLeft = `calc(${width})`
    explorer.showResults = true
    document.getElementById("showSearchResultsButton").classList.add("active-searchbar-button")
  }
  else {
    sidebar.style.marginLeft = `calc(0px - (${sidebar.style.width}))`
    // sidebar.style.width = "0px"
    mainBlock.style.marginLeft = "0px"
    explorer.showResults = false
    document.getElementById("showSearchResultsButton").classList.remove("active-searchbar-button")
  }

  // make sure top padding exludes search box
  adjustSidebarTopPadding('0px')

  updateUrlHash()
}

explorer.showSearchFilters = function() {
  let filtersBlock = document.getElementById("filtersBlock")
  if (!filtersBlock.style.height || filtersBlock.style.height === "0px") {
    explorer.toggleFilters()
  }
}

explorer.toggleFilters = function() {
  let filtersBlock = document.getElementById("filtersBlock")
  let adjustment = 0
  if (!filtersBlock.style.height || filtersBlock.style.height === "0px") {
    adjustment = `${filtersBlock.scrollHeight}px`
    filtersBlock.style.height = filtersBlock.scrollHeight + 'px'
    explorer.showFilters = true
    document.getElementById("showDataFiltersButton").classList.add("active-searchbar-button")
  }
  else {
    adjustment = `-${filtersBlock.scrollHeight}px`
    filtersBlock.style.height = "0px"
    explorer.showFilters = false
    document.getElementById("showDataFiltersButton").classList.remove("active-searchbar-button")
  }

  adjustSidebarTopPadding(adjustment)

  updateUrlHash()

}

explorer.showSearchSettings = function() {
  let groupBlock = document.getElementById("settingsBlock")
  if (!groupBlock.style.height || groupBlock.style.height === "0px") {
    explorer.toggleSettings()
  }
}

explorer.toggleSettings = function() {
  let groupBlock = document.getElementById("settingsBlock")
  let adjustment = 0
  if (!groupBlock.style.height || groupBlock.style.height === "0px") {
    adjustment = `${groupBlock.scrollHeight}px`
    groupBlock.style.height = groupBlock.scrollHeight + 'px'
    explorer.showSettings = true
    document.getElementById("showSettingsButton").classList.add("active-searchbar-button")
  }
  else {
    adjustment = `-${groupBlock.scrollHeight}px`
    groupBlock.style.height = "0px"
    explorer.showSettings = false
    document.getElementById("showSettingsButton").classList.remove("active-searchbar-button")
  }

  adjustSidebarTopPadding(adjustment)

  updateUrlHash()

}


explorer.toggleDataDownloads = function() {

  let optionsBlock = document.getElementById("plotOptions")
  let groupBlock = document.getElementById("plotCornerExtension")
  let widthIFrame = document.getElementById("plotWidthIframe")

  let transitionTime = 300
  let transitionTargetWidth = 0
  let transitionStartWidth = 0

  let maxWidth = Array.from(document.querySelectorAll(".plot-extension")).reduce((acc, element) => Math.max(acc, element.scrollWidth || 1.0), 0.0)

  if (!groupBlock.style.width || groupBlock.style.width === "0px") {
    transitionTargetWidth = maxWidth
    // transitionTargetWidth = 0.5*widthIFrame.clientWidth
    transitionStartWidth = 0
    explorer.showDataDownloads = true
    document.getElementById("showDataDownloadsButton").classList.add("active-toolbar-button")
  }
  else {
    transitionTargetWidth = 0
    transitionStartWidth = maxWidth
    explorer.showDataDownloads = false
    document.getElementById("showDataDownloadsButton").classList.remove("active-toolbar-button")
  }

  let startTime = performance.now()

  let transitionAnimation = function(time) {
    let u = Math.min((time - startTime)/transitionTime, 1.0)
    let width = transitionStartWidth*(1.0-u) + transitionTargetWidth*(u)
    let widthString = width + 'px'
    groupBlock.style.width = widthString

    document.querySelectorAll(".plot-extension").forEach((element) => element.style.width = widthString)

    explorer.resizePlotWidth()
    if (time - startTime < transitionTime)
      window.requestAnimationFrame(transitionAnimation)
  }

  window.requestAnimationFrame(transitionAnimation)



  updateUrlHash()

}

explorer.updateProgressText = function(text) {
  let progressBlock = document.getElementById("progressBlock")
  let progressText = document.getElementById("searchProgressText")
  let shouldClose = !text && progressText.textContent
  let shouldOpen = !progressText.textContent && text
  progressText.textContent = text

  let adjustment = 0
  let progressStyle = window.getComputedStyle(progressBlock)
  if (shouldOpen)
  {
    adjustment = `calc(${progressBlock.scrollHeight}px - ${progressStyle.paddingTop})`
    progressBlock.style.height = adjustment
  }
  else if (shouldClose)
  {
    adjustment = `calc(-${progressBlock.scrollHeight}px + ${progressStyle.paddingTop})`
    progressBlock.style.height = "0px"
  }

  adjustSidebarTopPadding(adjustment)

}

explorer.updateStatusInfo = function() {
  let infoText = ""
  if (explorer.statusInfo.numFeedsTotal === undefined) {
    infoText = "Loading feeds…"
  } 
  else if (explorer.statusInfo.numFeedsReceived < explorer.statusInfo.numFeedsTotal) {
    let percentComplete = 100.0*explorer.statusInfo.numFeedsReceived/explorer.statusInfo.numFeedsTotal
    infoText = `${explorer.statusInfo.numSearchResults} matches in ${explorer.statusInfo.numFeedsReceived} feeds (${percentComplete.toFixed(1)}% loaded).`
  }
  else {
    infoText = `${explorer.statusInfo.numSearchResults} matches in ${explorer.statusInfo.numFeedsReceived} feeds.`
  }

  explorer.updateProgressText(infoText)
}

explorer.updateEsdrLoadProgress = function(numFeedsReceived, numFeedsTotal) {

  explorer.statusInfo.numFeedsReceived = numFeedsReceived
  explorer.statusInfo.numFeedsTotal = numFeedsTotal

  explorer.updateStatusInfo()
}

explorer.esdrFeedsReceived = function(feedIds, progress) {
  explorer.updateEsdrLoadProgress(progress.current, progress.total)

  // set with all feeds rejected to start with
  explorer.mapOverlay.setDataSource(esdr, {rejectedFeeds: new Set(feedIds)})

  // update plot labels
  let feedSet = new Set(feedIds)
  for ([channelId, plotId] of explorer.plots) {
    let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    if (feedSet.has(feedId)) {
      let label = document.getElementById(`plotLabel-${plotId}`)
      if (label) {
        let channelName = channelId.slice(channelId.indexOf(".")+1)
        label.textContent = esdr.feeds.get(feedId).channelLabels.get(channelName)
      }
    }
  }

}

function processNewSearchResults(newResults, isAppendUpdate) {
  // this function receives a list of search results in the {feedId: , channelNames:} format
  // if isAppendUpdate is true, this is an incremental search result, and results can be appended
  // otherwise clear search results list
  // console.log(`processNewSearchResults(${newResults.length}, ${isAppendUpdate})`)

  let searchResultsList = document.getElementById("searchResultsList")

  // remove previous results on full update
  if (!isAppendUpdate) {
    clearSearchResultsList()
    explorer.results = []
  }

  explorer.results = explorer.results.concat(newResults)


  // update map markers
  let resultFeedIds = explorer.results.map(result => result.feedId)
  explorer.mapOverlay.filterMarkers(resultFeedIds)

  explorer.statusInfo.numSearchResults = explorer.results.length

  explorer.updateStatusInfo()
  // update search results list
  appendSearchResultsListIfNeeded(newResults)
}

function clearSearchResultsList() {
  let searchResultsList = document.getElementById("searchResultsList")
  while (searchResultsList.childElementCount) {
    searchResultsList.removeChild(searchResultsList.lastChild)
  }

}

function appendSearchResultsListBy(results) {
  // this function just adds more entries to the search results

  let feedDivs = []
  for (let result of results) {
    let feedId = result.feedId
    let feed = esdr.feeds.get(feedId)
    let channelNames = result.channels
    let feedDiv = searchResultsDivForFeed(feedId)
    if (channelNames)
    {
      let channelDivs = []
      for (let channelName of channelNames) {
        let chdiv = searchResultsDivForChannel(feedId, channelName, "searchResults")
        channelDivs.push(chdiv)
      }

      for (let chdiv of channelDivs) {
        feedDiv.appendChild(chdiv)
      }
    }
    feedDivs.push(feedDiv)

  }

  let searchResultsList = document.getElementById("searchResultsList")

  for (div of feedDivs)
  {
    searchResultsList.appendChild(div)
  }
}

function appendSearchResultsListIfNeeded() {
  let searchTotal = explorer.results.length

  let results = explorer.results.slice(searchResultsList.children.length)

  // if we have items to be added
  if (results.length > 0)
  {
    let shouldAppend = false
    if (searchResultsList.children.length > 0)
    {
      // if the last item is less than 100px from the bottom, append some more
      let itemBottom = searchResultsList.children[searchResultsList.children.length-1].getBoundingClientRect().bottom;
      let containerBottom = searchResultsList.getBoundingClientRect().bottom;
      shouldAppend = itemBottom - containerBottom < 100
    }
    else
    {
      shouldAppend = true
    }

    if (shouldAppend)
    {
      // add at least 10, at most 100 based on the length of the list already
      // cap to the number of actually available results
      let addCount = Math.min(results.length, Math.min(100, Math.max(10, Math.floor(searchResultsList.children.length*0.5))))
      appendSearchResultsListBy(results.slice(0, addCount))
      // call this function again until div is full enough
      appendSearchResultsListIfNeeded()
    }
    // console.log(`${itemBottom} of ${containerBottom}`)
  }


}


function searchResultsDivForFeed(feedId) {
  let feed = esdr.feeds.get(feedId)
  let label = esdr.labelForFeed(feedId)

  let div = document.createElement("div")
  div.setAttribute("id", `feed-${feedId}`)
  div.setAttribute("class", "search-result-feed-block")

  if (feed.latlng) {
    label += ` (N ${feed.latlng.lat.toFixed(6)}, E ${feed.latlng.lng.toFixed(6)})`
  }

  let labelElement = document.createElement("label")
  labelElement.setAttribute("id", `label-${feedId}`)
  labelElement.innerText = label

  div.appendChild(labelElement)

  return div
}


function getChannelIdFromElementId(elementId) {
  let hyphenLoc = elementId.indexOf("-")
  let channelId = elementId.slice(hyphenLoc+1)
  return channelId
}


function searchResultsDivForChannel(feedId, channelName, elementIdPrefix) {
  let label = esdr.labelForChannel(feedId, channelName)
  let channelId = `${feedId}.${channelName}`
  let selected = esdr.isChannelSelected(channelId)

  let div = document.createElement("div")
  div.setAttribute("class", "search-result-channel-block")
  div.addEventListener("mouseover", event => {
    explorer.mapOverlay.highlightMarkers([feedId], true)
  })

  let checkbox = document.createElement("input")
  checkbox.setAttribute("type", "checkbox")
  checkbox.setAttribute("id", `${elementIdPrefix}-${channelId}`)
  checkbox.setAttribute("name", `checkbox-${channelId}`)
  checkbox.setAttribute("title", "Plot Channel")
  if (selected) {
    checkbox.checked = true
  }
  checkbox.onclick = function(event) {
    let checked = this.checked
    let channelId = getChannelIdFromElementId(this.getAttribute("id"))

    explorer.interactiveSelectChannelWithId(channelId, checked)
  }
  div.appendChild(checkbox)


  let labelElement = document.createElement("label")
  labelElement.setAttribute("for", `${elementIdPrefix}-${channelId}`)
  labelElement.setAttribute("id", `label-${channelId}`)
  labelElement.innerText = label

  div.appendChild(labelElement)

  return div
}

explorer.interactiveSelectChannelWithId = function(channelId, isSelected) {

  let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
  let channelName = channelId.slice(channelId.indexOf(".")+1)

  esdr.selectChannelWithId(channelId, isSelected)
  explorer.mapOverlay.selectFeed(feedId, isSelected, true)

  if (isSelected) {
    explorer.addPlot(feedId, channelName)
    if (explorer.showSparklines)
      explorer.mapOverlay.addSparklinePlot(feedId, channelName)
  }
  else {
    explorer.removePlot(feedId, channelName)
    explorer.mapOverlay.removeSparklinePlot(feedId, channelName)
  }

  let resultsCheckbox = document.getElementById(`searchResults-${channelId}`)
  if (resultsCheckbox)
    resultsCheckbox.checked = isSelected
  let infoCheckbox = document.getElementById(`searchResults-${channelId}`)
  if (infoCheckbox)
    infoCheckbox.checked = isSelected

  updateUrlHash()
}



// bodytrack grapher calls this when it's ready
window.grapherLoad = function() {
  let now = Date.now() / 1000;
  let aWeekAgo = now - 7 * 24 * 60 * 60;

  let startTime = explorer.startTime || aWeekAgo
  let endTime = explorer.endTime || now
  let cursorTime = explorer.cursorTime || now

  explorer.plotManager = new org.bodytrack.grapher.PlotManager("date_axis", startTime, endTime);

  explorer.plotManager.getDateAxis().setCursorPosition(cursorTime);

  // FIXME: remove border from axis that is added by CREATE grapher
  let dateAxisElement = document.getElementById("date_axis")
  dateAxisElement.style.border = "none"


  explorer.scrubTimelineDate = function(timestamp) {
    let oldTimestamp = explorer.scrubTimestamp
    explorer.scrubTimestamp = timestamp

    if (oldTimestamp) {
      let dt = timestamp - oldTimestamp
      let dateAxis = explorer.plotManager.getDateAxis()
      let currentRange = dateAxis.getRange()
      let dateDiff = currentRange.max - currentRange.min
      let dateScrub = dateDiff*dt/1000.0*explorer.scrubSpeed/100.0
      dateAxis.setRange(currentRange.min + dateScrub, currentRange.max + dateScrub)
    }


    if (explorer.scrubSpeed != 0)
      window.requestAnimationFrame(explorer.scrubTimelineDate)
  }
  explorer.scrubTimelineDateWithSpeed = function(speed) {
    // if speed was zero, this is a new scrub, so reset timestamp
    if (explorer.scrubSpeed == 0)
      explorer.scrubTimestamp = undefined
    explorer.scrubSpeed = speed
    window.requestAnimationFrame(explorer.scrubTimelineDate)
  }
  explorer.scrubTimelineZoom = function(timestamp) {
    let oldTimestamp = explorer.scrubTimestamp
    explorer.scrubTimestamp = timestamp

    if (oldTimestamp) {
      let dt = timestamp - oldTimestamp
      let dateAxis = explorer.plotManager.getDateAxis()
      let currentRange = dateAxis.getRange()
      let dateDiff = currentRange.max - currentRange.min
      let dateScrub = dateDiff*dt/1000.0*explorer.scrubSpeed/100.0
      let targetSize = dateDiff - 2*dateScrub
      explorer.zoomTimelineToSize(targetSize)
    }


    if (explorer.scrubSpeed != 0)
      window.requestAnimationFrame(explorer.scrubTimelineZoom)
  }
  explorer.scrubTimelineZoomWithSpeed = function(speed) {
    // if speed was zero, this is a new scrub, so reset timestamp
    if (explorer.scrubSpeed == 0)
      explorer.scrubTimestamp = undefined
    explorer.scrubSpeed = speed
    window.requestAnimationFrame(explorer.scrubTimelineZoom)
  }
  explorer.stopScrubbing = function() {
    explorer.scrubSpeed = 0
  }

  let plotDateScrubber = document.getElementById("plotsDateScrubber")
  plotDateScrubber.addEventListener("mouseup", event => {
    event.target.value = "0"
    explorer.stopScrubbing()
    // FIXME: this is a hack for Firefox, which sends an input even after mouseup, thus preventing the slider to be properly reset in this callback
    // also add timeout to clear the flag so that we can subsequently click on slider again to make things move
    explorer.hasDateMoveScrubberMouseUpJustHappened = true
    if (explorer.dateMoveScrubberMouseUpTimer)
      clearTimeout(explorer.dateMoveScrubberMouseUpTimer)
    explorer.dateMoveScrubberMouseUpTimer = setTimeout(
      timestamp => explorer.hasDateMoveScrubberMouseUpJustHappened = false, 
      100
    )
  })
  plotDateScrubber.addEventListener("mouseDown", event => {
    explorer.hasDateMoveScrubberMouseUpJustHappened = false
  })
  plotDateScrubber.addEventListener("input", event => {
    if (explorer.hasDateMoveScrubberMouseUpJustHappened) {
      explorer.hasDateMoveScrubberMouseUpJustHappened = false
      event.target.value = "0"      
    } 
    else {
      explorer.scrubTimelineDateWithSpeed(event.target.valueAsNumber)
    }
  })
  let plotZoomScrubber = document.getElementById("plotsZoomScrubber")
  plotZoomScrubber.addEventListener("mouseup", event => {
    event.target.value = "0"
    explorer.stopScrubbing()
    // FIXME: this is a hack for Firefox, which sends an input even after mouseup, thus preventing the slider to be properly reset in this callback
    // also add timeout to clear the flag so that we can subsequently click on slider again to make things move
    explorer.hasDateZoomScrubberMouseUpJustHappened = true
    if (explorer.dateZoomScrubberMouseUpTimer)
      clearTimeout(explorer.dateZoomScrubberMouseUpTimer)
    explorer.dateZoomScrubberMouseUpTimer = setTimeout(
      timestamp => explorer.hasDateZoomScrubberMouseUpJustHappened = false, 
      100
    )
  })
  plotZoomScrubber.addEventListener("mouseDown", event => {
    explorer.hasDateZoomScrubberMouseUpJustHappened = false
  })
  plotZoomScrubber.addEventListener("input", event => {
    if (explorer.hasDateZoomScrubberMouseUpJustHappened) {
      explorer.hasDateZoomScrubberMouseUpJustHappened = false
      event.target.value = "0"      
    } 
    explorer.scrubTimelineZoomWithSpeed(event.target.valueAsNumber)
  })

  explorer.plotManager.getDateAxis().addAxisChangeListener(dateAxisProperties => {
    // do a deferred update
    if (explorer.deferredTimelineUpdateTimer)
      clearTimeout(explorer.deferredTimelineUpdateTimer)

    if (explorer.showSparklines) {
      window.requestAnimationFrame(timestamp => {
        explorer.mapOverlay.updateSparklineTimeRange({min: dateAxisProperties.min, max: dateAxisProperties.max})
        explorer.mapOverlay.draw()
      })
    }

    explorer.deferredTimelineUpdateTimer = setTimeout(explorer.deferredTimelineUpdateCallback, 300, dateAxisProperties.min, dateAxisProperties.max, dateAxisProperties.cursorPosition)
  })

  // setup datasource before adding sparklines, so that dataSource is in place
  explorer.mapOverlay.setDataSource(esdr, {})


  // add selected plots to plot manager
  for (let channelId of esdr.selectedChannelIds) {
    let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    let channelName = channelId.slice(channelId.indexOf(".")+1)
    explorer.addPlot(feedId, channelName)

    if (explorer.showSparklines) {
      explorer.mapOverlay.addSparklinePlot(feedId, channelName)
    }
  }

  // the iframe madness is for making sure the plots are resized right when the plot pane size changes

  // call setWidth at least once
  explorer.resizePlotWidth

  let widthIFrame = document.getElementById("plotWidthIframe")
  widthIFrame.contentWindow.addEventListener('resize', explorer.resizePlotWidth)

  let heightIFrame = document.getElementById("plotHeightIframe")
  widthIFrame.contentWindow.addEventListener('resize', function(event) {
    // console.log(`plotHeightIframe resize`)
  } )

  // timezones support
  let timezones = moment.tz.names()

  let timezoneDatalist = document.getElementById("timezoneDatalist")
  timezones.forEach(tz => {
    let opt = document.createElement("option")
    opt.value = tz
    timezoneDatalist.appendChild(opt)
  })
}

explorer.updateDataDownloadLinks = function() {
  let tz = document.getElementById("timezoneSelectorInput").value

  // get current timezone from browser
  if (tz == "Current Browser Timezone") {
    tz = moment.tz.guess(true)
  }

  // if we don't have a timerange to work with, don't even bother
  if (!explorer.startTime || !explorer.endTime) {
    return
  }

  for (let [channelId, plotId] of explorer.plots) {
    let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    let channelName = channelId.slice(channelId.indexOf(".")+1)
    let csvLink = esdr.getExportLink(feedId, channelName, explorer.startTime, explorer.endTime, "csv", tz.length > 0 ? tz : undefined)
    document.getElementById(`plotlink_csv-${plotId}`).setAttribute("href", csvLink)
    let jsonLink = esdr.getExportLink(feedId, channelName, explorer.startTime, explorer.endTime, "json", tz.length > 0 ? tz : undefined)
    document.getElementById(`plotlink_json-${plotId}`).setAttribute("href", jsonLink)
  }
}

explorer.downloadTimezoneChanged = function(event) {
  explorer.updateDataDownloadLinks()
}

explorer.resizePlotWidth = function() {
  let widthIFrame = document.getElementById("plotWidthIframe")
  let cornerElement = document.getElementById("plotCorner")
  let extensionElement = document.getElementById("plotCornerExtension")

  let plotWidth = widthIFrame.clientWidth - plotCorner.clientWidth - plotCornerExtension.clientWidth

  // resize plot overlays
  document.querySelectorAll(".plot-overlay").forEach((element) => element.style.width = plotWidth + 'px')


  explorer.plotManager.setWidth(plotWidth)
}

function animateNormalizedParameter(dt, start, now) {
  let u = Math.min(Math.max((now - start)/dt, 0.0), 1.0)
  return u
}

explorer.zoomTimelineToSize = function(zoomTargetSize) {
  let dateAxis = explorer.plotManager.getDateAxis()
  let currentRange = dateAxis.getRange()
  let cursor = dateAxis.getCursorPosition()

  let zoomCenter = ((cursor >= currentRange.min) && (cursor <= currentRange.max)) ? cursor : 0.5*(currentRange.max + currentRange.min)

  let rangeDiff = currentRange.max - currentRange.min
  let loDiff = zoomCenter - currentRange.min
  let hiDiff = currentRange.max - zoomCenter
  let zoomScale = zoomTargetSize/rangeDiff
  dateAxis.setRange(zoomCenter - loDiff*zoomScale, zoomCenter + hiDiff*zoomScale)

}

explorer.zoomTimelineByFactor = function(zoomScale) {
  let dateAxis = explorer.plotManager.getDateAxis()
  let currentRange = dateAxis.getRange()
  let cursor = dateAxis.getCursorPosition()

  let zoomCenter = ((cursor >= currentRange.min) && (cursor <= currentRange.max)) ? cursor : 0.5*(currentRange.max + currentRange.min)

  let rangeDiff = currentRange.max - currentRange.min
  let loDiff = zoomCenter - currentRange.min
  let hiDiff = currentRange.max - zoomCenter
  dateAxis.setRange(zoomCenter - loDiff*zoomScale, zoomCenter + hiDiff*zoomScale)

}


explorer.zoomTimelineByFactorAnimated = function(zoomScale) {
  let dateAxis = explorer.plotManager.getDateAxis()
  let srcRange = dateAxis.getRange()
  // let cursor = dateAxis.getCursorPosition()

  // let zoomCenter = ((cursor >= currentRange.min) && (cursor <= currentRange.max)) ? cursor : 0.5*(currentRange.max + currentRange.min)

  let rangeDiff = srcRange.max - srcRange.min

  if (explorer.timelineZoomAnimationDstRangeSize) {
    explorer.timelineZoomAnimationSrcRangeSize = rangeDiff
    rangeDiff = explorer.timelineZoomAnimationDstRangeSize
  }
  else
    explorer.timelineZoomAnimationSrcRangeSize = rangeDiff

  explorer.timelineZoomAnimationDstRangeSize = rangeDiff*zoomScale

  if (explorer.timelineZoomAnimationRequest) {
    window.cancelAnimationFrame(explorer.timelineZoomAnimationRequest)
  }

  let startTime = performance.now()
  let transitionTime = 300

  let animationFun = function(timestamp) {
    let u = animateNormalizedParameter(transitionTime, startTime, timestamp)
    let currentRange = dateAxis.getRange()
    let currentRangeSize = currentRange.max - currentRange.min
    let cursor = dateAxis.getCursorPosition()
    let newRangeSize = explorer.timelineZoomAnimationSrcRangeSize*(1.0-u) + explorer.timelineZoomAnimationDstRangeSize*u

    let zoomCenter = ((cursor >= currentRange.min) && (cursor <= currentRange.max)) ? cursor : 0.5*(currentRange.max + currentRange.min)

    let loDiff = (zoomCenter - currentRange.min)/currentRangeSize
    let hiDiff = (currentRange.max - zoomCenter)/currentRangeSize
    dateAxis.setRange(zoomCenter - loDiff*newRangeSize, zoomCenter + hiDiff*newRangeSize)

    if (u < 1.0) {
      explorer.timelineZoomAnimationRequest = window.requestAnimationFrame(animationFun)
    }
    else {
      explorer.timelineZoomAnimationSrcRangeSize = undefined
      explorer.timelineZoomAnimationDstRangeSize = undefined
      explorer.timelineZoomAnimationRequest = undefined
    }
  }

  explorer.timelineZoomAnimationRequest = window.requestAnimationFrame(animationFun)


}

explorer.moveTimelineByFactor = function(moveFactor) {
  let dateAxis = explorer.plotManager.getDateAxis()
  let currentRange = dateAxis.getRange()

  let rangeDiff = currentRange.max - currentRange.min
  dateAxis.setRange(currentRange.min - rangeDiff*moveFactor, currentRange.max - rangeDiff*moveFactor)

}

explorer.moveTimelineByFactorAnimated = function(moveFactor) {
  let dateAxis = explorer.plotManager.getDateAxis()
  let srcRange = dateAxis.getRange()

  let srcRangeMin = srcRange.min
  let srcRangeSize = srcRange.max - srcRange.min


  if (explorer.timelineMoveAnimationDstRangeStart) {
    explorer.timelineMoveAnimationSrcRangeStart = srcRangeMin
    srcRangeMin = explorer.timelineMoveAnimationDstRangeStart
  }
  else
    explorer.timelineMoveAnimationSrcRangeStart = srcRangeMin

  explorer.timelineMoveAnimationDstRangeStart = srcRangeMin + srcRangeSize*moveFactor

  if (explorer.timelineMoveAnimationRequest) {
    window.cancelAnimationFrame(explorer.timelineMoveAnimationRequest)
  }

  let startTime = performance.now()
  let transitionTime = 300

  let animationFun = function(timestamp) {
    let u = animateNormalizedParameter(transitionTime, startTime, timestamp)
    let currentRange = dateAxis.getRange()
    let currentRangeSize = currentRange.max - currentRange.min

    let newRangeMin = explorer.timelineMoveAnimationSrcRangeStart*(1.0-u) + explorer.timelineMoveAnimationDstRangeStart*u

    dateAxis.setRange(newRangeMin, newRangeMin + currentRangeSize)

    if (u < 1.0) {
      explorer.timelineMoveAnimationRequest = window.requestAnimationFrame(animationFun)
    }
    else {
      explorer.timelineMoveAnimationSrcRangeStart = undefined
      explorer.timelineMoveAnimationDstRangeStart = undefined
      explorer.timelineMoveAnimationRequest = undefined
    }
  }

  explorer.timelineMoveAnimationRequest = window.requestAnimationFrame(animationFun)

}

explorer.moveTimelineTo = function(timestamp, positionInView) {
  let dateAxis = explorer.plotManager.getDateAxis()
  let currentRange = dateAxis.getRange()

  let rangeDiff = currentRange.max - currentRange.min
  let loDiff = rangeDiff*(positionInView)
  let hiDiff = rangeDiff*(1.0-positionInView)
  dateAxis.setRange(timestamp - loDiff, timestamp + hiDiff)

}


explorer.deferredTimelineUpdateCallback = function(startTime, endTime, cursorTime) {
  // console.log(`deferredTimelineUpdateCallback(${startTime}, ${endTime}, ${cursorTime})`)
  explorer.startTime = startTime
  explorer.endTime = endTime
  explorer.cursorTime = cursorTime

  explorer.deferredTimelineUpdateTimer = undefined
  updateUrlHash()
  explorer.updateDataDownloadLinks();
}


explorer.addPlot = function(feedId, channelName) {
  let channelId = `${feedId}.${channelName}`

  if (explorer.plots.has(channelId)) {
    console.warn(`plot for ${channelId} already exists at number ${explorer.plots.get(channelId)}.`)
    return
  }

  let feed = esdr.feeds.get(feedId)

  // new plot number is next highest from current plots
  let plotId = Array.from(explorer.plots.values()).reduce((acc, val) => Math.max(acc,val), 0) + 1

  let channelLabel = feed ? feed.channelLabels.get(channelName) : channelId
  let plotName = `plot-${plotId}`
  let plotContainerName = `plotContainer-${plotId}`
  let yAxisName = `yaxis-${plotId}`

  let plotBlock = document.createElement("div")
  plotBlock.setAttribute("id", `plot-block-${plotId}`)
  // plotBlock.style.height = "5em"
  plotBlock.style.width = "100%"
  plotBlock.style.position = "relative"
  plotBlock.style.display = "flex"
  plotBlock.style.flexDirection = "row"
  plotBlock.style.alignItems = "stretch"
  plotBlock.style.borderBottom = "0.5px solid black"


  let plotContent = document.createElement("div")
  plotContent.setAttribute("id", plotContainerName)
  plotContent.style.height = "5em"

  // invisible plot overlay to prevent scroll events from happening
  let plotOverlay = document.createElement("div")
  plotOverlay.setAttribute("class", "plot-overlay")
  plotOverlay.setAttribute("id", `plotOverlay-${plotId}`)
  plotOverlay.style.width = "calc(100% - 2em)"
  plotOverlay.style.height = "100%"
  plotOverlay.style.position = "absolute"
  plotOverlay.style.zIndex = "1"

  plotOverlay.addEventListener("mouseover", event => {
    explorer.mapOverlay.highlightMarkers([feedId], true)
  })

  plotContent.appendChild(plotOverlay)

  let yAxis = document.createElement("div")
  yAxis.setAttribute("id", yAxisName)
  yAxis.style.height = "5em"
  yAxis.style.width = "2em"
  yAxis.style.flexShrink = "0"

  let labelBlock = document.createElement("div")
  labelBlock.setAttribute("id", `plotLabelBlock-${plotId}`)
  labelBlock.style.padding = "0.1em"
  labelBlock.style.display = "flex"
  labelBlock.style.alignItems = "center"
  labelBlock.style.position = "absolute"
  labelBlock.style.top = "0px"
  labelBlock.style.left = "0px"
  labelBlock.style.backgroundColor = "rgba(255,255,255,0.8)"
  // labelBlock.style.height = "100%"
  // labelBlock.style.width = "100%"
  labelBlock.style.width = "max-content"
  labelBlock.style.fontFamily = "sans-serif"
  labelBlock.style.fontSize = "smaller"
  labelBlock.style.zIndex = "2"
// labelBlock.textContent = channelLabel

  let labelClose = document.createElement("img")
  labelClose.setAttribute("class", "button-icon")
  labelClose.setAttribute("src", "cross.svg")
  labelClose.style.marginLeft = "0.25em"
  labelClose.style.marginRight = "0.25em"
  labelClose.addEventListener("click", () => explorer.interactiveSelectChannelWithId(channelId, false))

  let labelName = document.createElement("div")
  labelName.setAttribute("id", `plotLabel-${plotId}`)
  labelName.style.whiteSpace = "nowrap"

  labelName.textContent = channelLabel

  let extensionsBlock = document.createElement("div")
  extensionsBlock.setAttribute("id", `plot-extension-${plotId}`)
  extensionsBlock.setAttribute("class", "plot-extension")
  extensionsBlock.style.width = document.getElementById("plotCornerExtension").style.width
  // extensionsBlock.textContent = "here be downloads"

  let extensionsBox = document.createElement("div")
  extensionsBox.setAttribute("class", "plot-extension-box")
  extensionsBox.style.alignItems = "center"
  extensionsBox.style.height = "100%"

  {
    let spacer = document.createElement("div")
    spacer.style.flexGrow = 1
    spacer.style.width = "0px"
    extensionsBox.appendChild(spacer)
  }

  {
    let csvButtonGroup = document.createElement("a")
    csvButtonGroup.setAttribute("id", `plotlink_csv-${plotId}`)
    csvButtonGroup.setAttribute("class", "plots-shadow-group")
    csvButtonGroup.setAttribute("href", "https://foo.bar")
    csvButtonGroup.style.flexGrow = 0

    let csvDownloadButton = document.createElement("div")
    csvDownloadButton.setAttribute("class", "plots-toolbar-button plots-toolbar-group-left")
    csvDownloadButton.class = "plots-toolbar-button"
    csvDownloadButton.style.paddingRight = "0px"

    let csvDownloadIcon = document.createElement("img")
    csvDownloadIcon.setAttribute("class", "button-icon")
    csvDownloadIcon.src = "download.svg"

    let csvDownloadButton1 = document.createElement("div")
    csvDownloadButton1.setAttribute("class", "plots-toolbar-button plots-toolbar-group-right")
    csvDownloadButton1.textContent = "CSV"

    csvDownloadButton.appendChild(csvDownloadIcon)
    csvButtonGroup.appendChild(csvDownloadButton)
    csvButtonGroup.appendChild(csvDownloadButton1)
    extensionsBox.appendChild(csvButtonGroup)
  }

  {
    let spacer = document.createElement("div")
    spacer.style.flexGrow = 1
    spacer.style.width = "0px"
    extensionsBox.appendChild(spacer)
  }

  {
    let jsonButtonGroup = document.createElement("a")
    jsonButtonGroup.setAttribute("id", `plotlink_json-${plotId}`)
    jsonButtonGroup.setAttribute("class", "plots-shadow-group")
    jsonButtonGroup.setAttribute("href", "")
    jsonButtonGroup.style.flexGrow = 0

    let jsonDownloadButton = document.createElement("div")
    jsonDownloadButton.setAttribute("class", "plots-toolbar-button plots-toolbar-group-left")
    jsonDownloadButton.class = "plots-toolbar-button"
    jsonDownloadButton.style.paddingRight = "0px"

    let jsonDownloadIcon = document.createElement("img")
    jsonDownloadIcon.setAttribute("class", "button-icon")
    jsonDownloadIcon.src = "download.svg"

    let jsonDownloadButton1 = document.createElement("div")
    jsonDownloadButton1.setAttribute("class", "plots-toolbar-button plots-toolbar-group-right")
    jsonDownloadButton1.textContent = "JSON"

    jsonDownloadButton.appendChild(jsonDownloadIcon)
    jsonButtonGroup.appendChild(jsonDownloadButton)
    jsonButtonGroup.appendChild(jsonDownloadButton1)
    extensionsBox.appendChild(jsonButtonGroup)
  }

  {
    let spacer = document.createElement("div")
    spacer.style.flexGrow = 1
    spacer.style.width = "0px"
    extensionsBox.appendChild(spacer)
  }

  extensionsBlock.appendChild(extensionsBox)


  labelBlock.appendChild(labelClose)
  labelBlock.appendChild(labelName)

  plotBlock.appendChild(plotContent)
  plotBlock.appendChild(yAxis)
  plotBlock.appendChild(labelBlock)
  plotBlock.appendChild(extensionsBlock)



  let plotList = document.getElementById("plotList")
  plotList.appendChild(plotBlock)

  explorer.plots.set(channelId, plotId)


  explorer.plotManager.addDataSeriesPlot(plotId, esdr.dataSourceForChannel(feedId, channelName), plotContainerName, yAxisName, 0, 100, explorer.lineStyle)

  explorer.setPlotToHeight(plotId, explorer.plotHeight*explorer.plotBaseSize())

  // FIXME: remove border from plotContainer that is added by CREATE grapher
  plotContent.style.border = "none"

  let axisCanvas = document.getElementById("date_axis-x-axis-canvas")
  axisCanvas.style.position = "relative"


  explorer.plotManager.getPlotContainer(plotContainerName).setAutoScaleEnabled(true, true)

  // update download links in new plot (by being lazy and just updating them all)
  explorer.updateDataDownloadLinks()

  // TODO: data point listener only gets mouse events, but we have to block mouse events from grapher, otherwise we can't scroll
  // explorer.plotManager.getPlotContainer(plotContainerName).getPlot(plotId).addDataPointListener(function(value) {
  //     console.log(`plot-${plotId} value = ${value}`)
  // })

}

explorer.removePlot = function(feedId, channelName) {
  let channelId = `${feedId}.${channelName}`
  let plotId = explorer.plots.get(channelId)

  // if it didn't exist in the first place, don't bother
  if (!explorer.plots.has(channelId))
    return

  let plotName = `plot-${plotId}`
  let plotContainerName = `plotContainer-${plotId}`
  let yAxisName = `yaxis-${plotId}`

  let plot = explorer.plotManager.getPlot(plotId)


  let plotContainer = explorer.plotManager.getPlotContainer(plotContainerName)
  plotContainer.removeAllPlots()
  explorer.plotManager.removePlotContainer(plotContainerName)

  let plotBlock = document.getElementById(`plot-block-${plotId}`)
  if (plotBlock)
    plotBlock.remove()


  explorer.plots.delete(channelId)

}

explorer.highlightPlotsForFeeds = function(feedIds) {
  let feedIdsSet = new Set(feedIds)
  for (let [channelId, plotId] of explorer.plots) {
    let plotFeedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    let labelElement = document.getElementById(`plotLabelBlock-${plotId}`)
    if (feedIdsSet.has(plotFeedId)) {
      labelElement.style.backgroundColor = "hsla(210,100%,90%,0.8)"
    }
    else {
      labelElement.style.backgroundColor = "hsla(0,0%,100%,0.8)"
    }
  }
}

explorer.fitPlotYAxisToData = function(plotId) {
  let plotManager = explorer.plotManager
  let plotName = `plot-${plotId}`
  let yAxisName = `yaxis-${plotId}`
  let plot = plotManager.getPlot(plotId)
  let yAxis = plotManager.getYAxis(yAxisName)

  let stats = plot.getStatisticsWithinRange(plotManager.getDateAxis().getRange())

  if (isFinite(stats.min) && isFinite(stats.max)) {
    yAxis.setRange(stats.min, stats.max)
  }
}

explorer.setPlotAreaHeight = function(heightPercent) {
  explorer.plotAreaHeightPercent = Math.min(Math.max(heightPercent, explorer.minPlotAreaHeightPercent), explorer.maxPlotAreaHeightPercent)

  let plotArea = document.getElementById("plots")
  let mapArea = document.getElementById("googlemap")

  plotArea.style.height = `${explorer.plotAreaHeightPercent}%`
  mapArea.style.height = `${100-explorer.plotAreaHeightPercent}%`

  let decreaseButton = document.getElementById("decreasePlotAreaHeightButton")
  let increaseButton = document.getElementById("increasePlotAreaHeightButton")

  increaseButton.disabled = (explorer.plotAreaHeightPercent >= explorer.maxPlotAreaHeightPercent)
  decreaseButton.disabled = (explorer.plotAreaHeightPercent <= explorer.minPlotAreaHeightPercent)

}

explorer.increasePlotAreaHeight = function() {
  explorer.setPlotAreaHeight(explorer.plotAreaHeightPercent+20)
}

explorer.decreasePlotAreaHeight = function() {
  explorer.setPlotAreaHeight(explorer.plotAreaHeightPercent-20)
}

explorer.setPlotToHeight = function(plotId, height) {
  let plotContainerName = `plotContainer-${plotId}`
  let plotContainerElement = document.getElementById(plotContainerName)
  explorer.plotManager.getPlotContainer(plotContainerName).setHeight(height)
}

explorer.setPlotsToHeight = function(height) {
  for ([channelId, plotId] of explorer.plots) {
    let plotContainerName = `plotContainer-${plotId}`
    let plotContainerElement = document.getElementById(plotContainerName)

    explorer.plotManager.getPlotContainer(plotContainerName).setHeight(height)
  }
}

explorer.plotBaseSize = function() {
  let plotsContainerElement = document.getElementById("plotList")
  let lineSize = parseFloat(getComputedStyle(plotsContainerElement).fontSize);
  return lineSize
}

explorer.increasePlotHeight = function() {

  let lineSize = explorer.plotBaseSize();

  let decreaseButton = document.getElementById("decreasePlotHeightButton")
  let increaseButton = document.getElementById("increasePlotHeightButton")
  if (explorer.plotHeight == 2) {
    explorer.plotHeight = 5
    decreaseButton.disabled = false
    explorer.setPlotsToHeight(lineSize*5)
  }
  else if (explorer.plotHeight == 5) {
    explorer.plotHeight = 8
    explorer.setPlotsToHeight(lineSize*8)
  }
  else if (explorer.plotHeight == 8) {
    explorer.plotHeight = 12
    explorer.setPlotsToHeight(lineSize*12)
  }
  else if (explorer.plotHeight == 12) {
    explorer.plotHeight = 20
    explorer.setPlotsToHeight(lineSize*20)
    increaseButton.disabled = true
  }

  increaseButton.disabled = (explorer.plotHeight >= explorer.maxPlotHeight)
  decreaseButton.disabled = (explorer.plotHeight <= explorer.minPlotHeight)

  updateUrlHash()
}

explorer.decreasePlotHeight = function() {

  let lineSize = explorer.plotBaseSize();

  let decreaseButton = document.getElementById("decreasePlotHeightButton")
  let increaseButton = document.getElementById("increasePlotHeightButton")
  if (explorer.plotHeight == 20) {
    explorer.plotHeight = 12
    increaseButton.disabled = false
    explorer.setPlotsToHeight(lineSize*explorer.plotHeight)
  }
  else if (explorer.plotHeight == 12) {
    explorer.plotHeight = 8
    explorer.setPlotsToHeight(lineSize*explorer.plotHeight)
  }
  else if (explorer.plotHeight == 8) {
    explorer.plotHeight = 5
    explorer.setPlotsToHeight(lineSize*explorer.plotHeight)
  }
  else if (explorer.plotHeight == 5) {
    explorer.plotHeight = 2
    explorer.setPlotsToHeight(lineSize*explorer.plotHeight)
    decreaseButton.disabled = true
  }

  increaseButton.disabled = (explorer.plotHeight >= explorer.maxPlotHeight)
  decreaseButton.disabled = (explorer.plotHeight <= explorer.minPlotHeight)

  updateUrlHash()
}

// call initMap() as we fully loaded maps api to be able to extend the overlays in mapOverlay.js
initMap()
// initPlots()

</script>
   
</body>
</html> 

