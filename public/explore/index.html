<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8">
<style>

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
}

input[type="search"] {
  -webkit-appearance: textfield;
}

.sidebar {

  width: 0px;
  position: fixed;
  z-index: 2;
  /*use top and bottom instead of height attribute to make it fill the screen vertically*/
  top: 0;
  bottom: 0;
  left: 0;
  background-color: #EEE;
  font-family: sans-serif;
  overflow-x: hidden;
  /*overflow-y: scroll;*/
  box-shadow: 1px 0px 1px rgba(0,0,0, 0.1);
  transition: 0.3s;
  /*padding-top: 60px;*/
}

.sidebar .search-results {
  font-size: small;
  padding-left: 0.5em;
  padding-right: 0.5em;
  overflow-y: scroll;
  height: 100%;
}


.sidebar a {
  /*padding: 8px 8px 8px 32px;*/
  text-decoration: none;
  font-size: large;
  /*background-color: #818181;*/
  display: block;
  transition: 0.3s;
}

.sidebar a:hover {
  color: #f1f1f1;
}

.floaty-search {
  position: fixed;
  /*align-items: middle;*/
  top: 0px;
  left: 0px;
  margin: 0.5em;
  z-index: 2;
  float: right;
  /*display: table-row;*/
  /*font-size: 20px;*/
  background-color: #e7f3ff;
  color: black;
  padding: 5px 5px;
  /*border-width: 1px;*/
  /*border: 0.5px solid #777;*/
  border-radius: 3px;
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
  font-family: sans-serif;
}

.searchbar {
  display: flex;
  align-items: center;
  /*background-color: #777;*/
}

.searchbar-button {
  /*float: left;*/
  vertical-align: middle;
/*  font-size: 20px;
  cursor: pointer;
*/  
  font-size: large;
  height: inherit;
  background-color: inherit;
  /*background-color: #EEE;*/
  display: inline;
  /*color: white;*/
  /*padding: 10px 15px;*/
  border: none;
  cursor: pointer;
/*  padding: 0px;
  margin: 0px;
*/
  text-align: center;
}

.searchbar-divider {
  display: inline-block;
  height: 1.5em;
  width: 1px;
  background-color: rgba(0,0,0,0.2);
}

.search-text {
  border-radius: 3px;
  border: 0px solid rgba(0,0,0,0.2);
  box-shadow: 0px 0px 1px rgba(0,0,0,0.1);
  font-size: large;
}

.search-filters {
  height: 0px;
  overflow: hidden;
  /*display: none;*/
  transition: 0.3s;
}

.search-progress-block {
  height: 0px;
  overflow: hidden;
  transition: 0.3s
}

.search-result-feed-block {
  background-color: #FDD;
}
.search-result-channel-block {
  background-color: #FDF;
  font-size: smaller;
}

.graphs {
  height: 0px;
  overflow-y: scroll;
  /*display: none;*/
  transition: 0.3s;
}

.googlemap {
  /*display: inline-block;*/
/*  position: absolute;
  top: 0px;
  bottom: 0px;
*/  height: 60%;
  /*min-height: 100%;*/
  transition: 0.3s;
}

.map-overlay-static {
  position: absolute;
  z-index: -1;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  background-color: rgba(255,255,0,0.3);
  transition: margin-left 0.3s;
  pointer-events: none;
}

.plots-container {
  height: 40%;
  /*box-shadow: 0px 0px 2px rgba(0,0,0,0.1);*/
  /*overflow-y: scroll;*/
  transition: 0.3s;
  z-index: 1;
}

.plots-list {
  /*height: calc(100%-2em);*/
  /*box-shadow: 0px 0px 2px rgba(0,0,0,0.1);*/
  bottom: 0px;
  overflow-y: scroll;
  transition: 0.3s;
}

.plots-toolbar {
  display: flex;
  align-items: center;
  background-color: #EFE;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-bottom: 0.25em;
  padding-top: 0.25em;
}

.plots-date-scrubber {
  -webkit-appearance: none;
  height: 1em;
  border-radius: 3px;
  outline: none;
  background: #0F0;
}
.plots-date-scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 1.5em;
  width: 3em;
  border-radius: 3px;
  cursor: pointer;
  background: #F00;
}
.plots-date-scrubber::-moz-range-thumb {
  height: 1.5em;
  width: 3em;
  border-radius: 3px;
  cursor: pointer;
  background: #F00;
}

.plots-zoom-scrubber {
  -webkit-appearance: none;
  height: 1em;
  border-radius: 0.5em;
  outline: none;
  background: #0F0;
}
.plots-zoom-scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 1.5em;
  width: 1.5em;
  border-radius: 50%;
  cursor: pointer;
  background: #F00;
}
.plots-zoom-scrubber::-moz-range-thumb {
  height: 1.5em;
  width: 1.5em;
  border-radius: 50%;
  cursor: pointer;
  background: #F00;
}

.date-axis {
  height: 2em;
}


.plots-toolbar-button {
  vertical-align: middle;
  font-size: large;
  height: inherit;
  background-color: inherit;
  background-color: #EEF;
  border-radius: 3px;
  display: inline;
  /*color: white;*/
  /*padding: 10px 15px;*/
  border: none;
  cursor: pointer;
  margin-left: 0.25em;
  margin-right: 0.25em;
/*  padding: 0px;
  margin: 0px;
*/
  text-align: center;
}

#main {
  transition: margin-left .3s;
  /*padding: 16px;*/
  height: 100%;
}



/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */
@media screen and (max-height: 450px) {
  /*.sidebar {padding-top: 15px;}*/
  /*.sidebar a {font-size: 18px;}*/
}
</style>
</head>
<body>

<div id="searchSidebar" class="sidebar">
    <div id="searchResultsList" class="search-results"></div>
</div>

<div id="searchBlock" class="floaty-search">
  <div class="searchbar">
  <button class="searchbar-button" onclick="toggleSidebar()">☰</button>
  <div class="searchbar-divider"></div>
  <button class="searchbar-button" onclick="toggleFilters()">&gt;</button>
  <!-- <div class="searchbar-divider"></div> -->
  <input type="search" id="sensorSearchField" class="search-text" placeholder="search sensor feeds">
  <!-- <div class="searchbar-divider"></div> -->
  <button class="searchbar-button" onclick="doSensorSearch()">Search</button>
  </div>
  <div id="filtersBlock" class="search-filters">
    <div>Filter 1</div>
    <div>Filter 2</div>
  </div>
  <div id="progressBlock" class="search-progress-block">
    <div id="searchProgressText"></div>
  </div>
</div>



<div id="main">
  <div id="googlemap" class="googlemap"></div>
  <!-- <div id="mapOverlayStatic" class="map-overlay-static"></div> -->
  <div id="plots" class="plots-container">
    <div id="plotsToolbar" class="plots-toolbar">
        <input type="range" min="-100" max="100" value="0" class="plots-date-scrubber" id="plotsDateScrubber">
        <button class="plots-toolbar-button" onclick="">now</button>
        <input type="range" min="-100" max="100" value="0" class="plots-zoom-scrubber" id="plotsZoomScrubber">
        <button class="plots-toolbar-button" onclick="">day</button>
        <button class="plots-toolbar-button" onclick="">month</button>
        <button class="plots-toolbar-button" onclick="">year</button>
        <button class="plots-toolbar-button" onclick="">↑</button>
    </div>
    <div id="date_axis" class="date-axis"></div>
    <div id="plotList" class="plots-list">Here Be Plots</div>
  </div>
</div>

<script src="esdrFeeds.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCjVZHnH5L8ty50awHChDGdtJ5ZHqCFc-Y"></script>
<script src="mapOverlay.js"></script>

<script src="../lib/jquery/jquery-1.11.1.min.js" type="text/javascript"></script>
  <script src="../lib/superagent/superagent.js" type="text/javascript"></script>
<script src="../lib/bodytrack-grapher/org/bodytrack/grapher/grapher2.nocache.js" type="text/javascript"></script>
<script src="../lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>
  
  <!-- <script src="https://d3js.org/d3.v4.js"></script> -->


<script>

let gMap // google map instance
let esdr = new ESDR() // interface to ESDR data
let explorer = {
  results: [],
}

function initMap() {
  // parse the url hash part
  parseUrlParams()
  // execute params
  if (explorer.showFilters)
    showSearchFilters()
  if (explorer.showResults)
    showSearchResults()

  let mapdiv = document.getElementById('googlemap');
  gMap = new google.maps.Map(
    document.getElementById('googlemap'),
    {
      zoom: parseInt(explorer.zoom) || 5,
      center: explorer.center || new google.maps.LatLng(49.35720091782239, -92.91969375610346*0.0),

      streetViewControl: false,
      fullscreenControl: false,

      mapTypeControlOptions: {
        position: google.maps.ControlPosition.TOP_RIGHT,
      },

    }
  );

  explorer.mapOverlay = new MapOverlay(gMap, mapdiv)


  google.maps.event.addListener(gMap, 'bounds_changed', function() {
   // console.log(`bounds_changed event to ${map.getBounds()}`);
   let center = this.getCenter()
   explorer.center = center
   let zoom = this.getZoom()
   explorer.zoom = zoom

   updateUrlHash()
  })

  google.maps.event.addListener(gMap, 'mousemove', function(event) {
    let feedIds = explorer.mapOverlay.highlightMarkersAt(event.pixel)
    this.setOptions({
      draggableCursor: (feedIds.length > 0 ? 'default' :  null)
    });

  })

  google.maps.event.addListener(gMap, 'click', function(event) {
    if (!explorer.mapOverlay.markers)
      return

    explorer.mapOverlay.highlightMarkersAt(event.pixel)


    let div = document.createElement("div")
    // div.setAttribute("class", "search-result-channel-block")

    let highlightedFeedIds = Array.from(explorer.mapOverlay.markers.highlightedFeeds).sort()

    for (let feedId of highlightedFeedIds) {
      let feed = esdr.feeds.get(feedId)
      let feedDiv = searchResultsDivForFeed(feedId)
      if (feed && feed.channelBounds && feed.channelBounds.channels)
      {
        let channelDivs = []
        for (let channelName in feed.channelBounds.channels) {
          let chdiv = searchResultsDivForChannel(feedId, channelName)
          channelDivs.push(chdiv)
        }

        for (let chdiv of channelDivs) {
          feedDiv.appendChild(chdiv)
        }
      }
      div.appendChild(feedDiv)

    }

    if (this.infoWindow)
      this.infoWindow.close()

    if (highlightedFeedIds.length > 0) {
      let eventGeoCoords = explorer.mapOverlay.viewPixelToGeoCoords(event.pixel)
      this.infoWindow = new google.maps.InfoWindow({
        content: div,
        position: eventGeoCoords,
      })
      this.infoWindow.open(gMap)
    }
  })

  // install search response events
  let searchInput = document.getElementById("sensorSearchField")
  searchInput.addEventListener("change", event => {
    let searchText = event.target.value
    console.log(searchText)
    esdr.searchQuery = {text: searchText}
  })

  // install search results callback
  esdr.searchCallback = (searchResults, isAppendUpdate) => processNewSearchResults(searchResults, isAppendUpdate)
  // start loading feed data
  esdr.loadFeeds(esdrFeedsReceived)


  // install scroll listener
  let searchResultsList = document.getElementById("searchResultsList")
  searchResultsList.addEventListener('scroll', () => {
    appendSearchResultsListIfNeeded()
  })
}


function parseUrlParams() {
  let browserParams = new URLSearchParams(window.location.hash.slice(1))

  // selected channels for plotting
  if (browserParams.has("channels")) {
    let channelIds = browserParams.get("channels").split(",").filter((word) => word.length > 0)
    for (channelId of channelIds) {
      esdr.selectChannelWithId(channelId, true)
    }
  }

  // grapher time limits and cursor
  if (browserParams.has("time")) {
    let times = browserParams.get("time").split(",")
    explorer.startTime = times[0]
    explorer.endTime = times[1]
  }

  if (browserParams.has("cursor")) {
    explorer.cursorTime = browserParams.get("cursor")
  }

  // map params
  if (browserParams.has("zoom")) {
    explorer.zoom = browserParams.get("zoom")
  }

  if (browserParams.has("center")) {
    let latlon = browserParams.get("center").split(",")
    explorer.center = new google.maps.LatLng(latlon[0], latlon[1])
  }

  // search
  if (browserParams.has("search")) {
    let searchText = browserParams.get("search")
    explorer.search = {text: searchText}
  }

  // new params for display state
  if (browserParams.has("showFilters")) {
    explorer.showFilters = browserParams.get("showFilters") == "true"
  }
  if (browserParams.has("showResults")) {
    explorer.showResults = browserParams.get("showResults") == "true"
  }

}

function createUrlParams() {
  let browserParams = new URLSearchParams()

  if (esdr.selectedChannelIds.length > 0) {
    browserParams.set("channels", esdr.selectedChannelIds.join(','))
  }

  if (explorer.showFilters) {
    browserParams.set("showFilters", "true")
  }
  if (explorer.showResults) {
    browserParams.set("showResults", "true")
  }
  if (explorer.center) {
    browserParams.set("center", `${explorer.center.lat()},${explorer.center.lng()}`)
  }
  if (explorer.zoom) {
    browserParams.set("zoom", `${explorer.zoom}`)
  }

  return browserParams
}

function updateUrlHash() {
  let params = createUrlParams()
  // as URLSearchParams escapes commas, finally replace the escaped commas with human readable commas again
  window.location.hash = `#${params.toString().replace(/%2C/gi,',')}`
}




function adjustSidebarTopPadding(adjustment) {
  let searchBlock = document.getElementById("searchBlock")
  let searchStyle = window.getComputedStyle(searchBlock)
  let sidebar = document.getElementById("searchSidebar")

  sidebar.style.paddingTop = `calc(${searchBlock.offsetHeight}px + ${searchStyle.marginTop} + ${searchStyle.marginBottom} + (${adjustment}))`

}


function showSearchResults() {
  let sidebar = document.getElementById("searchSidebar")
  if (!sidebar.style.width || sidebar.style.marginLeft !== "0px") {
    toggleSidebar()
  }
}

function toggleSidebar() {
  let searchBlock = document.getElementById("searchBlock")
  let searchStyle = window.getComputedStyle(searchBlock)
  let sidebar = document.getElementById("searchSidebar")
  let mainBlock = document.getElementById("main")

  if (!sidebar.style.width || sidebar.style.marginLeft !== "0px") {
    // set the widths to show sidebar
    let blockWidth = searchBlock.scrollWidth + 'px'
    let margin = `${searchStyle.marginLeft} + ${searchStyle.marginRight}`
    let width = `${margin} + ${blockWidth}`
    sidebar.style.width = `calc(${width})`
    sidebar.style.left = `0px`
    sidebar.style.marginLeft = `0px`
    mainBlock.style.marginLeft = `calc(${width})`
    explorer.showResults = true
  }
  else {
    sidebar.style.marginLeft = `calc(0px - (${sidebar.style.width}))`
    // sidebar.style.width = "0px"
    mainBlock.style.marginLeft = "0px"
    explorer.showResults = false
  }

  // make sure top padding exludes search box
  adjustSidebarTopPadding('0px')

  updateUrlHash()
}

function showSearchFilters() {
  let filtersBlock = document.getElementById("filtersBlock")
  if (!filtersBlock.style.height || filtersBlock.style.height === "0px") {
    toggleFilters()
  }
}

function toggleFilters() {
  let filtersBlock = document.getElementById("filtersBlock")
  let adjustment = 0
  if (!filtersBlock.style.height || filtersBlock.style.height === "0px") {
    adjustment = `${filtersBlock.scrollHeight}px`
    filtersBlock.style.height = filtersBlock.scrollHeight + 'px'
    explorer.showFilters = true
  }
  else {
    adjustment = `-${filtersBlock.scrollHeight}px`
    filtersBlock.style.height = "0px"
    explorer.showFilters = false
  }

  adjustSidebarTopPadding(adjustment)

  updateUrlHash()

}

explorer.updateProgressText = function(text) {
  let progressBlock = document.getElementById("progressBlock")
  let progressText = document.getElementById("searchProgressText")
  let shouldClose = !text && progressText.textContent
  let shouldOpen = !progressText.textContent && text
  progressText.textContent = text

  let adjustment = 0
  if (shouldOpen)
  {
    adjustment = `${progressBlock.scrollHeight}px`
    progressBlock.style.height = progressBlock.scrollHeight + 'px'
  }
  else if (shouldClose)
  {
    adjustment = `-${progressBlock.scrollHeight}px`
    progressBlock.style.height = "0px"
  }

  adjustSidebarTopPadding(adjustment)

}

function updateEsdrLoadProgress(numFeedsReceived, numFeedsTotal) {

  if (numFeedsReceived < numFeedsTotal)
    explorer.updateProgressText(`Loading, received ${numFeedsReceived} of ${numFeedsTotal} feeds…`)
  else
    explorer.updateProgressText()
}

function esdrFeedsReceived(feedIds, progress) {
  updateEsdrLoadProgress(progress.current, progress.total)

  explorer.mapOverlay.setFeeds(Array.from(esdr.feeds.values()))
}

function processNewSearchResults(newResults, isAppendUpdate) {
  // this function receives a list of search results in the {feedId: , channelNames:} format
  // if isAppendUpdate is true, this is an incremental search result, and results can be appended
  // otherwise clear search results list
  console.log(`processNewSearchResults(${newResults.length}, ${isAppendUpdate})`)

  let searchResultsList = document.getElementById("searchResultsList")

  // remove previous results on full update
  if (!isAppendUpdate) {
    clearSearchResultsList()
    explorer.results = []
  }

  explorer.results = explorer.results.concat(newResults)


  // update map markers
  let resultFeedIds = explorer.results.map(result => result.feedId)
  explorer.mapOverlay.filterMarkers(resultFeedIds)

  explorer.updateProgressText(`Found ${explorer.results.length} matching feeds.`)
  // update search results list
  appendSearchResultsListIfNeeded(newResults)
}

function clearSearchResultsList() {
  let searchResultsList = document.getElementById("searchResultsList")
  while (searchResultsList.childElementCount) {
    searchResultsList.removeChild(searchResultsList.lastChild)
  }

}

function appendSearchResultsListBy(results) {
  // this function just adds more entries to the search results

  let feedDivs = []
  for (let result of results) {
    let feedId = result.feedId
    let feed = esdr.feeds.get(feedId)
    let channelNames = result.channels
    let feedDiv = searchResultsDivForFeed(feedId)
    if (channelNames)
    {
      let channelDivs = []
      for (let channelName of channelNames) {
        let chdiv = searchResultsDivForChannel(feedId, channelName)
        channelDivs.push(chdiv)
      }

      for (let chdiv of channelDivs) {
        feedDiv.appendChild(chdiv)
      }
    }
    feedDivs.push(feedDiv)

  }

  let searchResultsList = document.getElementById("searchResultsList")

  for (div of feedDivs)
  {
    searchResultsList.appendChild(div)
  }
}

function appendSearchResultsListIfNeeded() {
  let searchTotal = explorer.results.length

  let results = explorer.results.slice(searchResultsList.children.length)

  // if we have items to be added
  if (results.length > 0)
  {
    let shouldAppend = false
    if (searchResultsList.children.length > 0)
    {
      // if the last item is less than 100px from the bottom, append some more
      let itemBottom = searchResultsList.children[searchResultsList.children.length-1].getBoundingClientRect().bottom;
      let containerBottom = searchResultsList.getBoundingClientRect().bottom;
      shouldAppend = itemBottom - containerBottom < 100
    }
    else
    {
      shouldAppend = true
    }

    if (shouldAppend)
    {
      // add at least 10, at most 100 based on the length of the list already
      // cap to the number of actually available results
      let addCount = Math.min(results.length, Math.min(100, Math.max(10, Math.floor(searchResultsList.children.length*0.5))))
      appendSearchResultsListBy(results.slice(0, addCount))
      // call this function again until div is full enough
      appendSearchResultsListIfNeeded()
    }
    // console.log(`${itemBottom} of ${containerBottom}`)
  }


}


function searchResultsDivForFeed(feedId) {
  let feed = esdr.feeds.get(feedId)
  let label = esdr.labelForFeed(feedId)

  let div = document.createElement("div")
  div.setAttribute("id", `feed-${feedId}`)
  div.setAttribute("class", "search-result-feed-block")

  let labelElement = document.createElement("label")
  labelElement.setAttribute("id", `label-${feedId}`)
  labelElement.innerText = label

  div.appendChild(labelElement)

  return div
}


function getChannelIdFromElementId(elementId) {
  let hyphenLoc = elementId.indexOf("-")
  let channelId = elementId.slice(hyphenLoc+1)
  return channelId
}


function searchResultsDivForChannel(feedId, channelName) {
  let label = esdr.labelForChannel(feedId, channelName)
  let channelId = `${feedId}.${channelName}`
  let selected = esdr.isChannelSelected(channelId)

  let div = document.createElement("div")
  div.setAttribute("class", "search-result-channel-block")

  let checkbox = document.createElement("input")
  checkbox.setAttribute("type", "checkbox")
  checkbox.setAttribute("id", `checkbox-${channelId}`)
  checkbox.setAttribute("name", `checkbox-${channelId}`)
  if (selected)
  {
    checkbox.checked = true
  }
  checkbox.onclick = function() {
    let checked = this.checked
    let channelId = getChannelIdFromElementId(this.getAttribute("id"))
      esdr.selectChannelWithId(channelId, checked)

    updateUrlHash()
  }
  div.appendChild(checkbox)


  let labelElement = document.createElement("label")
  labelElement.setAttribute("for", `checkbox-${channelId}`)
  labelElement.setAttribute("id", `label-${channelId}`)
  labelElement.innerText = label

  div.appendChild(labelElement)

  return div
}


// bodytrack grapher calls this when it's ready
window.grapherLoad = function() {
  let now = Date.now() / 1000;
  let aWeekAgo = now - 7 * 24 * 60 * 60;

  explorer.plotManager = new org.bodytrack.grapher.PlotManager("date_axis", aWeekAgo, now);

  explorer.plotManager.setWillAutoResizeWidth(true, function() {
    return document.getElementById("plots").getBoundingClientRect().width
  });

  explorer.plotManager.getDateAxis().setCursorPosition(now);

  explorer.scrubTimelineDate = function(timestamp) {
    let oldTimestamp = explorer.scrubTimestamp
    explorer.scrubTimestamp = timestamp

    if (oldTimestamp) {
      let dt = timestamp - oldTimestamp
      let dateAxis = explorer.plotManager.getDateAxis()
      let currentRange = dateAxis.getRange()
      let dateDiff = currentRange.max - currentRange.min
      let dateScrub = dateDiff*dt/1000.0*explorer.scrubSpeed/100.0
      dateAxis.setRange(currentRange.min + dateScrub, currentRange.max + dateScrub)
    }


    if (explorer.scrubSpeed != 0)
      window.requestAnimationFrame(explorer.scrubTimelineDate)
  }
  explorer.scrubTimelineDateWithSpeed = function(speed) {
    // if speed was zero, this is a new scrub, so reset timestamp
    if (explorer.scrubSpeed == 0)
      explorer.scrubTimestamp = undefined
    explorer.scrubSpeed = speed
    window.requestAnimationFrame(explorer.scrubTimelineDate)
  }
  explorer.scrubTimelineZoom = function(timestamp) {
    let oldTimestamp = explorer.scrubTimestamp
    explorer.scrubTimestamp = timestamp

    if (oldTimestamp) {
      let dt = timestamp - oldTimestamp
      let dateAxis = explorer.plotManager.getDateAxis()
      let currentRange = dateAxis.getRange()
      let dateDiff = currentRange.max - currentRange.min
      let dateScrub = dateDiff*dt/1000.0*explorer.scrubSpeed/100.0
      dateAxis.setRange(currentRange.min + dateScrub, currentRange.max - dateScrub)
    }


    if (explorer.scrubSpeed != 0)
      window.requestAnimationFrame(explorer.scrubTimelineZoom)
  }
  explorer.scrubTimelineZoomWithSpeed = function(speed) {
    // if speed was zero, this is a new scrub, so reset timestamp
    if (explorer.scrubSpeed == 0)
      explorer.scrubTimestamp = undefined
    explorer.scrubSpeed = speed
    window.requestAnimationFrame(explorer.scrubTimelineZoom)
  }
  explorer.stopScrubbing = function() {
    explorer.scrubSpeed = 0
  }

  let plotDateScrubber = document.getElementById("plotsDateScrubber")
  plotDateScrubber.addEventListener("mouseup", event => {
    event.target.value = "0"
    explorer.stopScrubbing()
  })
  plotDateScrubber.addEventListener("input", event => {
    explorer.scrubTimelineDateWithSpeed(event.target.valueAsNumber)
  })
  let plotZoomScrubber = document.getElementById("plotsZoomScrubber")
  plotZoomScrubber.addEventListener("mouseup", event => {
    event.target.value = "0"
    explorer.stopScrubbing()
  })
  plotZoomScrubber.addEventListener("input", event => {
    explorer.scrubTimelineZoomWithSpeed(event.target.valueAsNumber)
  })
}

explorer.addPlot = function(channelId) {

}

// call initMap() as we fully loaded maps api to be able to extend the overlays in mapOverlay.js
initMap()
// initPlots()

</script>
   
</body>
</html> 

