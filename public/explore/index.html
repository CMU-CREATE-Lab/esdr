<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8">
<style>

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow-y: hidden;
}

input[type="search"] {
  -webkit-appearance: textfield;
}

.sidebar {

  width: 0px;
  position: fixed;
  z-index: 2;
  /*use top and bottom instead of height attribute to make it fill the screen vertically*/
  top: 0;
  bottom: 0;
  left: 0;
  background-color: #EEE;
  font-family: sans-serif;
  overflow-x: hidden;
  /*overflow-y: scroll;*/
  box-shadow: 1px 0px 1px rgba(0,0,0, 0.1);
  transition: 0.3s;
  /*padding-top: 60px;*/
}

.sidebar .search-results {
  font-size: small;
  padding-left: 0.5em;
  padding-right: 0.5em;
  overflow-y: scroll;
  height: 100%;
}


.sidebar a {
  /*padding: 8px 8px 8px 32px;*/
  text-decoration: none;
  font-size: large;
  /*background-color: #818181;*/
  display: block;
  transition: 0.3s;
}

.sidebar a:hover {
  color: #f1f1f1;
}

.floaty-search {
  position: fixed;
  /*align-items: middle;*/
  top: 0px;
  left: 0px;
  margin: 0.5em;
  z-index: 2;
  float: right;
  /*display: table-row;*/
  /*font-size: 20px;*/
  background-color: #e7f3ff;
  color: black;
  padding: 5px 5px;
  /*border-width: 1px;*/
  /*border: 0.5px solid #777;*/
  border-radius: 3px;
  box-shadow: 0px 1px 1px rgba(0,0,0,0.1);
  font-family: sans-serif;
}

.searchbar {
  display: flex;
  align-items: center;
  /*background-color: #777;*/
}

.searchbar-button {
  /*float: left;*/
  vertical-align: middle;
/*  font-size: 20px;
  cursor: pointer;
*/  
  font-size: large;
  height: inherit;
  background-color: inherit;
  /*background-color: #EEE;*/
  display: inline;
  /*color: white;*/
  /*padding: 10px 15px;*/
  border: none;
  cursor: pointer;
/*  padding: 0px;
  margin: 0px;
*/
  text-align: center;
}

.searchbar-divider {
  display: inline-block;
  height: 1.5em;
  width: 1px;
  background-color: rgba(0,0,0,0.2);
}

.search-text {
  border-radius: 3px;
  border: 0px solid rgba(0,0,0,0.2);
  box-shadow: 0px 0px 1px rgba(0,0,0,0.1);
  font-size: large;
}

.search-filters {
  height: 0px;
  overflow: hidden;
  /*display: none;*/
  transition: 0.3s;
}

.search-progress-block {
  height: 0px;
  overflow: hidden;
  transition: 0.3s
}

.search-result-feed-block {
  background-color: #FDD;
}
.search-result-channel-block {
  background-color: #FDF;
  font-size: smaller;
}

.graphs {
  height: 0px;
  overflow-y: scroll;
  /*display: none;*/
  transition: 0.3s;
}

.googlemap {
  /*display: inline-block;*/
/*  position: absolute;
  top: 0px;
  bottom: 0px;
*/  height: 60%;
  /*min-height: 100%;*/
  transition: 0.3s;
}

.map-overlay-static {
  position: absolute;
  z-index: -1;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  background-color: rgba(255,255,0,0.3);
  transition: margin-left 0.3s;
  pointer-events: none;
}

.plots-container {
  height: 40%;
  /*box-shadow: 0px 0px 2px rgba(0,0,0,0.1);*/
  overflow-y: hidden;
  display: flex;
  flex-direction: column;
  transition: 0.3s;
  /*z-index: 1;*/
}

.plots-list {
  /*height: calc(100%-2em);*/
  /*box-shadow: 0px 0px 2px rgba(0,0,0,0.1);*/
  flex-grow: 1;
/*  position: relative;
  top: 0px;
  bottom: 0px;
*/  overflow-y: scroll;
  transition: 0.3s;
}

.plots-toolbar {
  display: flex;
  flex-shrink: 0;
  align-items: center;
  background-color: #EFE;
  padding-left: 0.5em;
  padding-right: 0.5em;
  padding-bottom: 0.25em;
  padding-top: 0.25em;
}

.plots-date-scrubber {
  -webkit-appearance: none;
  height: 1em;
  border-radius: 3px;
  outline: none;
  background: #0F0;
}
.plots-date-scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 1.5em;
  width: 3em;
  border-radius: 3px;
  cursor: pointer;
  background: #F00;
}
.plots-date-scrubber::-moz-range-thumb {
  height: 1.5em;
  width: 3em;
  border-radius: 3px;
  cursor: pointer;
  background: #F00;
}

.plots-zoom-scrubber {
  -webkit-appearance: none;
  height: 1em;
  border-radius: 0.5em;
  outline: none;
  background: #0F0;
}
.plots-zoom-scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  height: 1.5em;
  width: 1.5em;
  border-radius: 50%;
  cursor: pointer;
  background: #F00;
}
.plots-zoom-scrubber::-moz-range-thumb {
  height: 1.5em;
  width: 1.5em;
  border-radius: 50%;
  cursor: pointer;
  background: #F00;
}

.date-axis {
  height: 2em;
}


.plots-toolbar-button {
  vertical-align: middle;
  font-size: large;
  height: inherit;
  background-color: inherit;
  background-color: #EEF;
  border-radius: 3px;
  display: inline;
  /*color: white;*/
  /*padding: 10px 15px;*/
  border: none;
  cursor: pointer;
  margin-left: 0.25em;
  margin-right: 0.25em;
/*  padding: 0px;
  margin: 0px;
*/
  text-align: center;
}

.button-icon {
  height: 1em; 
  vertical-align: middle;
  cursor: pointer;
}

#main {
  transition: margin-left .3s;
  /*padding: 16px;*/
  height: 100%;
  overflow-y: hidden;
}



/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */
@media screen and (max-height: 450px) {
  /*.sidebar {padding-top: 15px;}*/
  /*.sidebar a {font-size: 18px;}*/
}
</style>
</head>
<body>

<div id="searchSidebar" class="sidebar">
    <div id="searchResultsList" class="search-results"></div>
</div>

<div id="searchBlock" class="floaty-search">
  <div class="searchbar">
  <!-- <button class="searchbar-button" onclick="toggleSidebar()">☰</button> -->
  <button class="searchbar-button" onclick="toggleSidebar()"><img src="hamburger.svg" class="button-icon"></img></button>
  <div class="searchbar-divider"></div>
  <button class="searchbar-button" onclick="toggleFilters()"><img src="filter.svg" class="button-icon"></img></button>
  <!-- <div class="searchbar-divider"></div> -->
  <input type="search" id="sensorSearchField" class="search-text" placeholder="search sensor feeds">
  <!-- <div class="searchbar-divider"></div> -->
  <button class="searchbar-button" onclick="doSensorSearch()"><img src="loupe.svg" class="button-icon"></img></button>
  </div>
  <div id="filtersBlock" class="search-filters">
    <div><input type="checkbox" id="recentOnlyCheckbox" name="checkbox-recentOnly" title="only show sensors with new data from the last 30 days"><label for="checkbox-recentOnly">Data in last 30 days</label></div>
    <div><input type="checkbox" id="mapOnlyCheckbox" name="checkbox-mapOnly" title="only show sensors that are on the map area"><label for="checkbox-mapOnly">On Map</label></div>
  </div>
  <div id="progressBlock" class="search-progress-block">
    <div id="searchProgressText"></div>
  </div>
</div>



<div id="main">
  <div id="googlemap" class="googlemap"></div>
  <!-- <div id="mapOverlayStatic" class="map-overlay-static"></div> -->
  <div id="plots" class="plots-container">
    <div id="plotsToolbar" class="plots-toolbar">
        <input type="range" min="-100" max="100" value="0" class="plots-date-scrubber" id="plotsDateScrubber">
        <button class="plots-toolbar-button" onclick="">now</button>
        <input type="range" min="-100" max="100" value="0" class="plots-zoom-scrubber" id="plotsZoomScrubber">
        <button class="plots-toolbar-button" onclick="">day</button>
        <button class="plots-toolbar-button" onclick="">month</button>
        <button class="plots-toolbar-button" onclick="">year</button>
        <button class="plots-toolbar-button" onclick="">↑</button>
    </div>
    <div id="date_axis" class="date-axis"></div>
    <div id="plotList" class="plots-list"></div>
  </div>
</div>

<script src="esdrFeeds.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCjVZHnH5L8ty50awHChDGdtJ5ZHqCFc-Y"></script>
<script src="mapOverlay.js"></script>

<script src="../lib/jquery/jquery-1.11.1.min.js" type="text/javascript"></script>
  <script src="../lib/superagent/superagent.js" type="text/javascript"></script>
<script src="../lib/bodytrack-grapher/org/bodytrack/grapher/grapher2.nocache.js" type="text/javascript"></script>
<script src="../lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>
  
  <!-- <script src="https://d3js.org/d3.v4.js"></script> -->


<script>

let gMap // google map instance
let esdr = new ESDR() // interface to ESDR data
let explorer = {
  statusInfo: {
    numFeedsReceived: 0,
    numSearchResults: 0,
  },
  results: [],
  plots: new Map(),
  lineStyle: {
    "styles": [
      // {
      //   "type": "bar",
      //   "stripPosition": "center",
      //   "stripWidthSecs": 30,
      //   "rangedColors": "rgba(210,210,210,.8); 10;rgba(185,185,185,.8); 20;rgba(160,160,160,.8); 30;rgba(135,135,135,.8); 40;rgba(110,110,110,.8); 50;rgba(110,110,110,.8);60;rgba(85,85,85,.8);70;rgba(70,70,70,.8);80;rgba(50,50,50,.8)"
      // },
      {
        "type": "line",
        "lineWidth": 1,
        "show": true,
        "color": "rgba(60,60,60, .8)"
      }
    ],
    "highlight": {
      "lineWidth": 3,
      "styles": [{
          "show": true,
          "type": "lollipop",
          "color": "green",
          "radius": 0,
          "lineWidth": 1,
          "fill": false
        },
        {
          "type": "circle",
          radius: 3,
          "lineWidth": 0.5,
          "show": true,
          "color": "#ff0000",
          fill: true
        },
        {
          "show": true,
          "type": "value",
          "fillColor": "#000000",
          "marginWidth": 10,
          "font": "9pt Helvetica,Arial,Verdana,sans-serif",
          "verticalOffset": 7
        }
      ]
    }
  },

}

function initMap() {
  // parse the url hash part
  parseUrlParams()
  // execute params
  if (explorer.showResults)
    showSearchResults()

  // FIXME: showSearchFilters() with a small delay, otherwise the margin computation gets confused. maybe this could be done with less hackery?
  if (explorer.showFilters)
    setTimeout(showSearchFilters, 100)

  let mapdiv = document.getElementById('googlemap');
  gMap = new google.maps.Map(
    document.getElementById('googlemap'),
    {
      zoom: parseInt(explorer.zoom) || 5,
      center: explorer.center || new google.maps.LatLng(49.35720091782239, -92.91969375610346*0.0),

      streetViewControl: false,
      fullscreenControl: false,

      mapTypeControlOptions: {
        position: google.maps.ControlPosition.TOP_RIGHT,
      },

    }
  );

  explorer.mapOverlay = new MapOverlay(gMap, mapdiv)


  google.maps.event.addListener(gMap, 'bounds_changed', function() {
    // console.log(`bounds_changed event to ${map.getBounds()}`);

    if (explorer.deferredMapBoundsUpdateTimer)
      clearTimeout(explorer.deferredTimelineUpdateTimer)

    explorer.deferredMapBoundsUpdateTimer = setTimeout(explorer.deferredMapBoundsUpdateCallback, 300, gMap)

  })

  google.maps.event.addListener(gMap, 'mousemove', function(event) {
    let feedIds = explorer.mapOverlay.highlightMarkersAt(event.pixel, true)
    this.setOptions({
      draggableCursor: (feedIds.length > 0 ? 'default' :  null)
    });

  })

  google.maps.event.addListener(gMap, 'click', function(event) {
    if (!explorer.mapOverlay.markers)
      return

    explorer.mapOverlay.highlightMarkersAt(event.pixel, true)


    let div = document.createElement("div")
    // div.setAttribute("class", "search-result-channel-block")

    let highlightedFeedIds = Array.from(explorer.mapOverlay.markers.highlightedFeeds).sort()

    for (let feedId of highlightedFeedIds) {
      let feed = esdr.feeds.get(feedId)
      let feedDiv = searchResultsDivForFeed(feedId)
      if (feed && feed.channelBounds && feed.channelBounds.channels)
      {
        let channelDivs = []
        for (let channelName in feed.channelBounds.channels) {
          let chdiv = searchResultsDivForChannel(feedId, channelName, "infoWindow")
          channelDivs.push(chdiv)
        }

        for (let chdiv of channelDivs) {
          feedDiv.appendChild(chdiv)
        }
      }
      div.appendChild(feedDiv)

    }

    if (this.infoWindow)
      this.infoWindow.close()

    if (highlightedFeedIds.length > 0) {
      let eventGeoCoords = explorer.mapOverlay.viewPixelToGeoCoords(event.pixel)
      this.infoWindow = new google.maps.InfoWindow({
        content: div,
        position: eventGeoCoords,
      })
      this.infoWindow.open(gMap)
    }
  })

  let bounds = gMap.getBounds()
  explorer.mapBounds = bounds
  esdr.updateQuery({mapBounds: bounds})


  // install search response events
  let searchInput = document.getElementById("sensorSearchField")
  searchInput.addEventListener("change", event => {
    let searchText = event.target.value
    console.log(searchText)
    esdr.updateQuery({text: searchText})

    updateUrlHash()
  })
  let recentOnlyCheckbox = document.getElementById("recentOnlyCheckbox")
  recentOnlyCheckbox.addEventListener("change", event => {
    let checked = event.target.checked
    esdr.updateQuery({recentOnly: checked})

    updateUrlHash()
  })
  let mapOnlyCheckbox = document.getElementById("mapOnlyCheckbox")
  mapOnlyCheckbox.addEventListener("change", event => {
    let checked = event.target.checked
    esdr.updateQuery({mapOnly: checked})

    updateUrlHash()
  })

  // install search results callback
  esdr.searchCallback = (searchResults, isAppendUpdate) => processNewSearchResults(searchResults, isAppendUpdate)
  // start loading feed data
  esdr.loadFeeds(explorer.esdrFeedsReceived)

  esdr.channelDataUpdateCallback = (feedId, channelName) => {
    let channelId = `${feedId}.${channelName}`
    // console.log(`channelDataUpdateCallback(${channelId}`)
    let plotNumber = explorer.plots.get(channelId)
    if (plotNumber)
      explorer.fitPlotYAxisToData(plotNumber)
  }


  // install scroll listener
  let searchResultsList = document.getElementById("searchResultsList")
  searchResultsList.addEventListener('scroll', () => {
    appendSearchResultsListIfNeeded()
  })
}

explorer.deferredMapBoundsUpdateCallback = function(map) {
  explorer.deferredMapBoundsUpdateTimer = undefined

  let center = map.getCenter()
  explorer.center = center
  let zoom = map.getZoom()
  explorer.zoom = zoom
  let bounds = map.getBounds()
  explorer.mapBounds = bounds
  esdr.updateQuery({mapBounds: bounds})

  updateUrlHash()
}


function parseUrlParams() {
  let browserParams = new URLSearchParams(window.location.hash.slice(1))

  // selected channels for plotting
  if (browserParams.has("channels")) {
    // TODO: add support for pipe separator old-style URLs?
    let channelIds = browserParams.get("channels").split(",").filter((word) => word.length > 0)
    for (channelId of channelIds) {
      // select channel and add plot
      esdr.selectChannelWithId(channelId, true)
      // let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
      // let channelName = channelId.slice(channelId.indexOf(".")+1)
      // explorer.addPlot(feedId, channelName)
    }
  }

  // grapher time limits and cursor
  if (browserParams.has("time")) {
    let times = browserParams.get("time").split(",")
    let startTime = parseFloat(times[0])
    if (isFinite(startTime))
      explorer.startTime = startTime
    let endTime = parseFloat(times[1])
    if (isFinite(endTime))
      explorer.endTime = endTime
}

  if (browserParams.has("cursor")) {
    let cursorTime = parseFloat(browserParams.get("cursor"))
    if (isFinite(cursorTime))
      explorer.cursorTime = cursorTime
  }

  // map params
  if (browserParams.has("zoom")) {
    explorer.zoom = browserParams.get("zoom")
  }

  if (browserParams.has("center")) {
    let latlon = browserParams.get("center").split(",")
    explorer.center = new google.maps.LatLng(latlon[0], latlon[1])
  }

  // search
  if (browserParams.has("search")) {
    let searchText = browserParams.get("search")
    let searchInput = document.getElementById("sensorSearchField")
    searchInput.value = searchText
    esdr.updateQuery({text: searchText})
  }
  if (browserParams.has("recentOnly")) {
    let recentOnly = browserParams.get("recentOnly") == "true"
    let recentOnlyCheckbox = document.getElementById("recentOnlyCheckbox")
    recentOnlyCheckbox.checked = recentOnly
    esdr.updateQuery({recentOnly: recentOnly})
  }
  if (browserParams.has("mapOnly")) {
    let mapOnly = browserParams.get("mapOnly") == "true"
    let mapOnlyCheckbox = document.getElementById("mapOnlyCheckbox")
    mapOnlyCheckbox.checked = mapOnly
    esdr.updateQuery({mapOnly: mapOnly})
  }

  // new params for display state
  if (browserParams.has("showFilters")) {
    explorer.showFilters = browserParams.get("showFilters") == "true"
  }
  if (browserParams.has("showResults")) {
    explorer.showResults = browserParams.get("showResults") == "true"
  }

}

function createUrlParams() {
  let browserParams = new URLSearchParams()

  if (esdr.selectedChannelIds.length > 0) {
    browserParams.set("channels", esdr.selectedChannelIds.join(','))
  }
  if (explorer.startTime || explorer.endTime) {
    browserParams.set("time", [explorer.startTime.toFixed(3), explorer.endTime.toFixed(3)].join(','))
  }
  if (explorer.cursorTime) {
    browserParams.set("cursor", explorer.cursorTime.toFixed(3))
  }


  if (explorer.showFilters) {
    browserParams.set("showFilters", "true")
  }
  if (explorer.showResults) {
    browserParams.set("showResults", "true")
  }
  if (explorer.center) {
    browserParams.set("center", `${explorer.center.lat()},${explorer.center.lng()}`)
  }
  if (explorer.zoom) {
    browserParams.set("zoom", `${explorer.zoom}`)
  }
  if (esdr.searchQuery.recentOnly) {
    browserParams.set("recentOnly", `${esdr.searchQuery.recentOnly}`)
  }
  if (esdr.searchQuery.mapOnly) {
    browserParams.set("mapOnly", `${esdr.searchQuery.mapOnly}`)
  }

  if (esdr.searchQuery.text) {
    browserParams.set("search", esdr.searchQuery.text)
  }

  return browserParams
}

function updateUrlHash() {
  let params = createUrlParams()
  // as URLSearchParams escapes commas, finally replace the escaped commas with human readable commas again
  window.location.hash = `#${params.toString().replace(/%2C/gi,',')}`
}




function adjustSidebarTopPadding(adjustment) {
  let searchBlock = document.getElementById("searchBlock")
  let searchStyle = window.getComputedStyle(searchBlock)
  let sidebar = document.getElementById("searchSidebar")

  sidebar.style.paddingTop = `calc(${searchBlock.offsetHeight}px + ${searchStyle.marginTop} + ${searchStyle.marginBottom} + (${adjustment}))`

}


function showSearchResults() {
  let sidebar = document.getElementById("searchSidebar")
  if (!sidebar.style.width || sidebar.style.marginLeft !== "0px") {
    toggleSidebar()
  }
}

function toggleSidebar() {
  let searchBlock = document.getElementById("searchBlock")
  let searchStyle = window.getComputedStyle(searchBlock)
  let sidebar = document.getElementById("searchSidebar")
  let mainBlock = document.getElementById("main")

  if (!sidebar.style.width || sidebar.style.marginLeft !== "0px") {
    // set the widths to show sidebar
    let blockWidth = searchBlock.scrollWidth + 'px'
    let margin = `${searchStyle.marginLeft} + ${searchStyle.marginRight}`
    let width = `${margin} + ${blockWidth}`
    sidebar.style.width = `calc(${width})`
    sidebar.style.left = `0px`
    sidebar.style.marginLeft = `0px`
    mainBlock.style.marginLeft = `calc(${width})`
    explorer.showResults = true
  }
  else {
    sidebar.style.marginLeft = `calc(0px - (${sidebar.style.width}))`
    // sidebar.style.width = "0px"
    mainBlock.style.marginLeft = "0px"
    explorer.showResults = false
  }

  // make sure top padding exludes search box
  adjustSidebarTopPadding('0px')

  updateUrlHash()
}

function showSearchFilters() {
  let filtersBlock = document.getElementById("filtersBlock")
  if (!filtersBlock.style.height || filtersBlock.style.height === "0px") {
    toggleFilters()
  }
}

function toggleFilters() {
  let filtersBlock = document.getElementById("filtersBlock")
  let adjustment = 0
  if (!filtersBlock.style.height || filtersBlock.style.height === "0px") {
    adjustment = `${filtersBlock.scrollHeight}px`
    filtersBlock.style.height = filtersBlock.scrollHeight + 'px'
    explorer.showFilters = true
  }
  else {
    adjustment = `-${filtersBlock.scrollHeight}px`
    filtersBlock.style.height = "0px"
    explorer.showFilters = false
  }

  adjustSidebarTopPadding(adjustment)

  updateUrlHash()

}

explorer.updateProgressText = function(text) {
  let progressBlock = document.getElementById("progressBlock")
  let progressText = document.getElementById("searchProgressText")
  let shouldClose = !text && progressText.textContent
  let shouldOpen = !progressText.textContent && text
  progressText.textContent = text

  let adjustment = 0
  if (shouldOpen)
  {
    adjustment = `${progressBlock.scrollHeight}px`
    progressBlock.style.height = progressBlock.scrollHeight + 'px'
  }
  else if (shouldClose)
  {
    adjustment = `-${progressBlock.scrollHeight}px`
    progressBlock.style.height = "0px"
  }

  adjustSidebarTopPadding(adjustment)

}

explorer.updateStatusInfo = function() {
  let infoText = ""
  if (explorer.statusInfo.numFeedsTotal === undefined) {
    infoText = "Loading feeds…"
  } 
  else if (explorer.statusInfo.numFeedsReceived < explorer.statusInfo.numFeedsTotal) {
    let percentComplete = 100.0*explorer.statusInfo.numFeedsReceived/explorer.statusInfo.numFeedsTotal
    infoText = `${explorer.statusInfo.numSearchResults} matches in ${explorer.statusInfo.numFeedsReceived} feeds (${percentComplete.toFixed(1)}% loaded).`
  }
  else {
    infoText = `${explorer.statusInfo.numSearchResults} matches in ${explorer.statusInfo.numFeedsReceived} feeds.`
  }

  explorer.updateProgressText(infoText)
}

explorer.updateEsdrLoadProgress = function(numFeedsReceived, numFeedsTotal) {

  explorer.statusInfo.numFeedsReceived = numFeedsReceived
  explorer.statusInfo.numFeedsTotal = numFeedsTotal

  explorer.updateStatusInfo()
}

explorer.esdrFeedsReceived = function(feedIds, progress) {
  explorer.updateEsdrLoadProgress(progress.current, progress.total)

  // set with all feeds rejected to start with
  explorer.mapOverlay.setFeeds(Array.from(esdr.feeds.values()), {rejectedFeeds: new Set(feedIds)})

  // update plot labels
  let feedSet = new Set(feedIds)
  for ([channelId, plotId] of explorer.plots) {
    let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    if (feedSet.has(feedId)) {
      let label = document.getElementById(`plotLabel-${plotId}`)
      if (label) {
        let channelName = channelId.slice(channelId.indexOf(".")+1)
        label.textContent = esdr.feeds.get(feedId).channelLabels.get(channelName)
      }
    }
  }

}

function processNewSearchResults(newResults, isAppendUpdate) {
  // this function receives a list of search results in the {feedId: , channelNames:} format
  // if isAppendUpdate is true, this is an incremental search result, and results can be appended
  // otherwise clear search results list
  // console.log(`processNewSearchResults(${newResults.length}, ${isAppendUpdate})`)

  let searchResultsList = document.getElementById("searchResultsList")

  // remove previous results on full update
  if (!isAppendUpdate) {
    clearSearchResultsList()
    explorer.results = []
  }

  explorer.results = explorer.results.concat(newResults)


  // update map markers
  let resultFeedIds = explorer.results.map(result => result.feedId)
  explorer.mapOverlay.filterMarkers(resultFeedIds)

  explorer.statusInfo.numSearchResults = explorer.results.length

  explorer.updateStatusInfo()
  // update search results list
  appendSearchResultsListIfNeeded(newResults)
}

function clearSearchResultsList() {
  let searchResultsList = document.getElementById("searchResultsList")
  while (searchResultsList.childElementCount) {
    searchResultsList.removeChild(searchResultsList.lastChild)
  }

}

function appendSearchResultsListBy(results) {
  // this function just adds more entries to the search results

  let feedDivs = []
  for (let result of results) {
    let feedId = result.feedId
    let feed = esdr.feeds.get(feedId)
    let channelNames = result.channels
    let feedDiv = searchResultsDivForFeed(feedId)
    if (channelNames)
    {
      let channelDivs = []
      for (let channelName of channelNames) {
        let chdiv = searchResultsDivForChannel(feedId, channelName, "searchResults")
        channelDivs.push(chdiv)
      }

      for (let chdiv of channelDivs) {
        feedDiv.appendChild(chdiv)
      }
    }
    feedDivs.push(feedDiv)

  }

  let searchResultsList = document.getElementById("searchResultsList")

  for (div of feedDivs)
  {
    searchResultsList.appendChild(div)
  }
}

function appendSearchResultsListIfNeeded() {
  let searchTotal = explorer.results.length

  let results = explorer.results.slice(searchResultsList.children.length)

  // if we have items to be added
  if (results.length > 0)
  {
    let shouldAppend = false
    if (searchResultsList.children.length > 0)
    {
      // if the last item is less than 100px from the bottom, append some more
      let itemBottom = searchResultsList.children[searchResultsList.children.length-1].getBoundingClientRect().bottom;
      let containerBottom = searchResultsList.getBoundingClientRect().bottom;
      shouldAppend = itemBottom - containerBottom < 100
    }
    else
    {
      shouldAppend = true
    }

    if (shouldAppend)
    {
      // add at least 10, at most 100 based on the length of the list already
      // cap to the number of actually available results
      let addCount = Math.min(results.length, Math.min(100, Math.max(10, Math.floor(searchResultsList.children.length*0.5))))
      appendSearchResultsListBy(results.slice(0, addCount))
      // call this function again until div is full enough
      appendSearchResultsListIfNeeded()
    }
    // console.log(`${itemBottom} of ${containerBottom}`)
  }


}


function searchResultsDivForFeed(feedId) {
  let feed = esdr.feeds.get(feedId)
  let label = esdr.labelForFeed(feedId)

  let div = document.createElement("div")
  div.setAttribute("id", `feed-${feedId}`)
  div.setAttribute("class", "search-result-feed-block")

  let labelElement = document.createElement("label")
  labelElement.setAttribute("id", `label-${feedId}`)
  labelElement.innerText = label

  div.appendChild(labelElement)

  return div
}


function getChannelIdFromElementId(elementId) {
  let hyphenLoc = elementId.indexOf("-")
  let channelId = elementId.slice(hyphenLoc+1)
  return channelId
}


function searchResultsDivForChannel(feedId, channelName, elementIdPrefix) {
  let label = esdr.labelForChannel(feedId, channelName)
  let channelId = `${feedId}.${channelName}`
  let selected = esdr.isChannelSelected(channelId)

  let div = document.createElement("div")
  div.setAttribute("class", "search-result-channel-block")
  div.addEventListener("mouseover", event => {
    explorer.mapOverlay.highlightMarkers([feedId], true)
  })

  let checkbox = document.createElement("input")
  checkbox.setAttribute("type", "checkbox")
  checkbox.setAttribute("id", `${elementIdPrefix}-${channelId}`)
  checkbox.setAttribute("name", `checkbox-${channelId}`)
  checkbox.setAttribute("title", "Plot Channel")
  if (selected) {
    checkbox.checked = true
  }
  checkbox.onclick = function(event) {
    let checked = this.checked
    let channelId = getChannelIdFromElementId(this.getAttribute("id"))

    explorer.interactiveSelectChannelWithId(channelId, checked)
  }
  div.appendChild(checkbox)


  let labelElement = document.createElement("label")
  labelElement.setAttribute("for", `checkbox-${channelId}`)
  labelElement.setAttribute("id", `label-${channelId}`)
  labelElement.innerText = label

  div.appendChild(labelElement)

  return div
}

explorer.interactiveSelectChannelWithId = function(channelId, isSelected) {
  esdr.selectChannelWithId(channelId, isSelected)

  let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
  let channelName = channelId.slice(channelId.indexOf(".")+1)
  if (isSelected) {
    explorer.addPlot(feedId, channelName)
  }
  else {
    explorer.removePlot(feedId, channelName)
  }

  let resultsCheckbox = document.getElementById(`searchResults-${channelId}`)
  if (resultsCheckbox)
    resultsCheckbox.checked = isSelected
  let infoCheckbox = document.getElementById(`searchResults-${channelId}`)
  if (infoCheckbox)
    infoCheckbox.checked = isSelected

  updateUrlHash()
}


// bodytrack grapher calls this when it's ready
window.grapherLoad = function() {
  let now = Date.now() / 1000;
  let aWeekAgo = now - 7 * 24 * 60 * 60;

  let startTime = explorer.startTime || aWeekAgo
  let endTime = explorer.endTime || now
  let cursorTime = explorer.cursorTime || now

  explorer.plotManager = new org.bodytrack.grapher.PlotManager("date_axis", startTime, endTime);

  explorer.plotManager.setWillAutoResizeWidth(true, function() {
    return document.getElementById("plots").getBoundingClientRect().width
  });

  explorer.plotManager.getDateAxis().setCursorPosition(cursorTime);

  explorer.scrubTimelineDate = function(timestamp) {
    let oldTimestamp = explorer.scrubTimestamp
    explorer.scrubTimestamp = timestamp

    if (oldTimestamp) {
      let dt = timestamp - oldTimestamp
      let dateAxis = explorer.plotManager.getDateAxis()
      let currentRange = dateAxis.getRange()
      let dateDiff = currentRange.max - currentRange.min
      let dateScrub = dateDiff*dt/1000.0*explorer.scrubSpeed/100.0
      dateAxis.setRange(currentRange.min + dateScrub, currentRange.max + dateScrub)
    }


    if (explorer.scrubSpeed != 0)
      window.requestAnimationFrame(explorer.scrubTimelineDate)
  }
  explorer.scrubTimelineDateWithSpeed = function(speed) {
    // if speed was zero, this is a new scrub, so reset timestamp
    if (explorer.scrubSpeed == 0)
      explorer.scrubTimestamp = undefined
    explorer.scrubSpeed = speed
    window.requestAnimationFrame(explorer.scrubTimelineDate)
  }
  explorer.scrubTimelineZoom = function(timestamp) {
    let oldTimestamp = explorer.scrubTimestamp
    explorer.scrubTimestamp = timestamp

    if (oldTimestamp) {
      let dt = timestamp - oldTimestamp
      let dateAxis = explorer.plotManager.getDateAxis()
      let currentRange = dateAxis.getRange()
      let dateDiff = currentRange.max - currentRange.min
      let dateScrub = dateDiff*dt/1000.0*explorer.scrubSpeed/100.0
      dateAxis.setRange(currentRange.min + dateScrub, currentRange.max - dateScrub)
    }


    if (explorer.scrubSpeed != 0)
      window.requestAnimationFrame(explorer.scrubTimelineZoom)
  }
  explorer.scrubTimelineZoomWithSpeed = function(speed) {
    // if speed was zero, this is a new scrub, so reset timestamp
    if (explorer.scrubSpeed == 0)
      explorer.scrubTimestamp = undefined
    explorer.scrubSpeed = speed
    window.requestAnimationFrame(explorer.scrubTimelineZoom)
  }
  explorer.stopScrubbing = function() {
    explorer.scrubSpeed = 0
  }

  let plotDateScrubber = document.getElementById("plotsDateScrubber")
  plotDateScrubber.addEventListener("mouseup", event => {
    event.target.value = "0"
    explorer.stopScrubbing()
  })
  plotDateScrubber.addEventListener("input", event => {
    explorer.scrubTimelineDateWithSpeed(event.target.valueAsNumber)
  })
  let plotZoomScrubber = document.getElementById("plotsZoomScrubber")
  plotZoomScrubber.addEventListener("mouseup", event => {
    event.target.value = "0"
    explorer.stopScrubbing()
  })
  plotZoomScrubber.addEventListener("input", event => {
    explorer.scrubTimelineZoomWithSpeed(event.target.valueAsNumber)
  })

  explorer.plotManager.getDateAxis().addAxisChangeListener(dateAxisProperties => {
    // do a deferred update
    if (explorer.deferredTimelineUpdateTimer)
      clearTimeout(explorer.deferredTimelineUpdateTimer)

    explorer.deferredTimelineUpdateTimer = setTimeout(explorer.deferredTimelineUpdateCallback, 300, dateAxisProperties.min, dateAxisProperties.max, dateAxisProperties.cursorPosition)
  })

  // add selected plots to plot manager
  for (let channelId of esdr.selectedChannelIds) {
    let feedId = parseInt(channelId.slice(0, channelId.indexOf(".")))
    let channelName = channelId.slice(channelId.indexOf(".")+1)
    explorer.addPlot(feedId, channelName)
  }
}

explorer.deferredTimelineUpdateCallback = function(startTime, endTime, cursorTime) {
  // console.log(`deferredTimelineUpdateCallback(${startTime}, ${endTime}, ${cursorTime})`)
  explorer.startTime = startTime
  explorer.endTime = endTime
  explorer.cursorTime = cursorTime

  explorer.deferredTimelineUpdateTimer = undefined
  updateUrlHash()
}


explorer.addPlot = function(feedId, channelName) {
  let channelId = `${feedId}.${channelName}`

  if (explorer.plots.has(channelId)) {
    console.warn(`plot for ${channelId} already exists at number ${explorer.plots.get(channelId)}.`)
    return
  }

  let feed = esdr.feeds.get(feedId)

  // new plot number is next highest from current plots
  let plotId = Array.from(explorer.plots.values()).reduce((acc, val) => Math.max(acc,val), 0) + 1

  let channelLabel = feed ? feed.channelLabels.get(channelName) : channelId
  let plotName = `plot-${plotId}`
  let plotContainerName = `plotContainer-${plotId}`
  let yAxisName = `yaxis-${plotId}`

  let plotBlock = document.createElement("div")
  plotBlock.setAttribute("id", `plot-block-${plotId}`)
  plotBlock.style.height = "5em"
  plotBlock.style.width = "100%"
  plotBlock.style.position = "relative"


  let plotContent = document.createElement("div")
  plotContent.setAttribute("id", plotContainerName)
  plotContent.style.position = "absolute"
  plotContent.style.left = "0px"
  plotContent.style.top = "0px"
  plotContent.style.bottom = "0px"
  // plotContent.style.height = "5em"
  plotContent.style.right = "2em"

  let yAxis = document.createElement("div")
  yAxis.setAttribute("id", yAxisName)
  yAxis.style.position = "absolute"
  yAxis.style.right = "0px"
  yAxis.style.top = "0px"
  yAxis.style.bottom = "0px"
  // yAxis.style.height = "5em"
  yAxis.style.width = "2em"

  let labelBlock = document.createElement("div")
  // labelBlock.setAttribute("id", `plotLabel-${plotId}`)
  labelBlock.style.display = "flex"
  labelBlock.style.alignItems = "center"
  labelBlock.style.position = "absolute"
  labelBlock.style.top = "0px"
  labelBlock.style.left = "0px"
  // labelBlock.style.height = "100%"
  labelBlock.style.width = "100%"
  labelBlock.style.fontFamily = "sans-serif"
  labelBlock.style.fontSize = "smaller"
  // labelBlock.textContent = channelLabel

  let labelClose = document.createElement("img")
  labelClose.setAttribute("class", "button-icon")
  labelClose.setAttribute("src", "cross.svg")
  labelClose.style.marginLeft = "0.25em"
  labelClose.style.marginRight = "0.25em"
  labelClose.addEventListener("click", () => explorer.interactiveSelectChannelWithId(channelId, false))

  let labelName = document.createElement("div")
  labelName.setAttribute("id", `plotLabel-${plotId}`)
  labelName.textContent = channelLabel

  labelBlock.appendChild(labelClose)
  labelBlock.appendChild(labelName)

  let plotDivider = document.createElement("div")
  // plotDivider.setAttribute("id", `divider-${plotId}`)
  plotDivider.style.bottom = "0px"
  plotDivider.style.height = "1px"
  plotDivider.style.width = "100%"
  plotDivider.style.position = "absolute"
  plotDivider.style.backgroundColor = "#000"

  plotBlock.appendChild(plotContent)
  plotBlock.appendChild(yAxis)
  plotBlock.appendChild(labelBlock)
  plotBlock.appendChild(plotDivider)

  let plotList = document.getElementById("plotList")
  plotList.appendChild(plotBlock)

  explorer.plots.set(channelId, plotId)

  explorer.plotManager.addDataSeriesPlot(plotId, esdr.dataSourceForChannel(feedId, channelName), plotContainerName, yAxisName, 0, 100, explorer.lineStyle, range => {
    let paddedRange = Object.assign({}, range)
    return paddedRange
  })

}

explorer.removePlot = function(feedId, channelName) {
  let channelId = `${feedId}.${channelName}`
  let plotId = explorer.plots.get(channelId)

  // if it didn't exist in the first place, don't bother
  if (!explorer.plots.has(channelId))
    return

  let plotName = `plot-${plotId}`
  let plotContainerName = `plotContainer-${plotId}`
  let yAxisName = `yaxis-${plotId}`

  let plot = explorer.plotManager.getPlot(plotId)


  let plotContainer = explorer.plotManager.getPlotContainer(plotContainerName)
  plotContainer.removePlot(plot)
  explorer.plotManager.removePlotContainer(plotContainerName)

  let plotBlock = document.getElementById(`plot-block-${plotId}`)
  if (plotBlock)
    plotBlock.remove()


  explorer.plots.delete(channelId)

}

explorer.fitPlotYAxisToData = function(plotId) {
  let plotManager = explorer.plotManager
  let plotName = `plot-${plotId}`
  let yAxisName = `yaxis-${plotId}`
  let plot = plotManager.getPlot(plotId)
  let yAxis = plotManager.getYAxis(yAxisName)

  let stats = plot.getStatisticsWithinRange(plotManager.getDateAxis().getRange())

  if ((stats.minValue !== null) && (stats.maxValue !== null)) {
    yAxis.setRange(stats.minValue, stats.maxValue)
  }
}

// call initMap() as we fully loaded maps api to be able to extend the overlays in mapOverlay.js
initMap()
// initPlots()

</script>
   
</body>
</html> 

