<!DOCTYPE HTML>
<html>
<head>
   <title>Browse ESDR</title>
   <meta http-equiv="content-type" content="text/html;charset=utf-8" />
   <style type="text/css">
      body {
         font-family: 'Open Sans', 'Helvetica', sans-serif !important;
         font-weight: 400 !important;
         font-size: 16px !important;
         margin: 3px;
         width: 100%;
         height: 100%;
         overflow-y: hidden;
      }

      .plot_container {
         position: relative;``
         border: 1px solid black;
      }

      .plot_container > canvas:focus {
         outline: none;
      }

      .date_axis {
         height: 42px;
         z-index: 2;
         border: 1px solid black;
         border-bottom-width: 0;
      }

      .y_axis {
         position: relative;
         width: 42px;
         border: 1px solid black;
         border-left-width: 0;
      }

      .y_axis_label {
         position: absolute;
         text-align: center;
         font-size: 8pt;
         height: auto;
      }

      .rotate_90 {
         transform: rotate(90deg);
         -ms-transform: rotate(90deg);
         -webkit-transform: rotate(90deg);
      }

      #channel_switcher_panel {
         text-align: center;
         margin-top: 10px;
         margin-bottom: 20px;
         font-size: smaller;
      }

      .channel_link, .time_range_link {
         display: inline-block;
         margin-left: 10px;
         margin-right: 10px;
         cursor: pointer;
      }

      #time_range_switcher_panel {
         text-align: center;
         margin-top: 10px;
         margin-bottom: 20px;
         font-size: smaller;
      }

      #value_and_time {
         position: absolute;
         display: none;
         top: 2px;
         right: 2px;
         background-color: rgba(255, 255, 255, 0.9);
         margin: 2px;
         padding: 2px;
         font-size: 11px;
         line-height: 11px;
      }
   </style>

   <script src="https://esdr.cmucreatelab.org/lib/jquery/jquery-1.11.1.min.js" type="text/javascript"></script>
   <script src="https://esdr.cmucreatelab.org/lib/superagent/superagent.js" type="text/javascript"></script>
   <script src="https://esdr.cmucreatelab.org/lib/bodytrack-grapher/org/bodytrack/grapher/grapher2.nocache.js" type="text/javascript"></script>
   <script src="https://esdr.cmucreatelab.org/lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>

   <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
   <script src="http://api.cmucreatelab.org/exp-0.1/js/utils.js"></script>
   <script src="..\series2.js"></script> 
   <script src="http://api.cmucreatelab.org/exp-0.1/js/CanvasLayer.js"></script>

   <script language="JavaScript" type="text/javascript">

      //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   esdr start  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      var feedLocList = {latlng: [], index: [], color: []}; 
      var ESDR_API_ROOT_URL = 'https://esdr.cmucreatelab.org/api/v1';
      var DEFAULT_CHANNEL = 'particle_concentration';

      var selectedFeedIdOrApiKey = null;
      var selectedChannelName = null;

      var channelUnits = null;

      var showNumList = []; 

      var pm25 = []; 
      var pm10 = []; 
      var ozone = []; 
      var no = []; 
      var no2 = []; 
      var so2 = []; 
      var co = []; 
      var speck = []; 


      //Jquery cache for all selectors 
      var $allSelect = null; 

      var allFeedNums = []; 

      // grapher stuff
      var plotManager;
      var feed = null;
      var availableChannels = [];
      var isAutoScaleOn = false;

      //WebGL stuff
      var alpha = 0.70; 
      var currentPointSize = 0; 

      function setRangeFromSecondsAgoToNow(numSecondsAgo) {
         var now = Date.now() / 1000;
         var min = now - numSecondsAgo;
         plotManager.getDateAxis().constrainRangeTo(Math.min(min, feed.minTimeSecs), now);
         plotManager.getDateAxis().setRange(min, now);
      }

      var timeRangeOptions = [
         {
            "label" : "all data",
            "handler" : function() {
               plotManager.getDateAxis().setRange(feed.minTimeSecs, feed.maxTimeSecs);
            }
         },
         {
            "label" : "past 30 days",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*24*30);
            }
         },
         {
            "label" : "past 7 days",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*24*7);
            }
         },
         {
            "label" : "past 24 hours",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*24);
            }
         },
         {
            "label" : "past 12 hours",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*12);
            }
         },
         {
            "label" : "past hour",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600);
            }
         },
      ];

      function setTimeRange(rangeName) {
         var rangeFunction = timeRangeOptions[rangeName];
         if (typeof rangeFunction === 'function') {
            var range = rangeFunction();
            if (range && 'min' in range && 'max' in range) {
               plotManager.getDateAxis().setRange(range['min'], range['max']);
            }
         }
      }

      // Got this from: http://css-tricks.com/snippets/javascript/get-url-variables/
      function getQueryVariable(variable) {
         var query = window.location.search.substring(1);
         var vars = query.split("&");
         for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            if (pair[0] == variable) {
               return pair[1];
            }
         }
         return null;
      }

      var style = {
         "styles" : [
            // { "type" : "line", "lineWidth" : 1, "show" : true, "color" : "red" },
            // { "type" : "circle", radius : 3, "lineWidth" : 1, "show" : true, "color" : "blue", fill : false }
            {
                     "type" : "bar",
                     "stripPosition" : "center",
                     "stripWidthSecs" : 3600,
                     "rangedColors" : "rgb(0,255,0); 3;rgb(47,255,0); 6;rgb(110,255,0); 9;rgb(180,255,0); 12;rgb(255,255,0); 15;rgb(255,177,0);18;rgb(255,107,0);21;rgb(255,46,0);24;rgb(255,0,0)"
                  },
            { "type" : "line", "lineWidth" : 1, "show" : true, "color" : "black" }
         ],
         "highlight" : {
            "lineWidth" : 1,
            "styles" : [
               {
                  "show" : true,
                  "type" : "lollipop",
                  "color" : "green",
                  "radius" : 0,
                  "lineWidth" : 1,
                  "fill" : false
               },
               {
                  "type" : "circle",
                  radius : 3,
                  "lineWidth" : 0.5,
                  "show" : true,
                  "color" : "#ff0000",
                  fill : true
               },
               {
                  "show" : true,
                  "type" : "value",
                  "fillColor" : "#000000",
                  "marginWidth" : 10,
                  "font" : "9pt Helvetica,Arial,Verdana,sans-serif",
                  "verticalOffset" : 7
               }
            ]
         }
      };

      function createDatasource(source) {
         var split = source.split('.');
         if (split.length != 2) {
            console.log('createDatasource must have source of form ID.channel but was ' + source);
            return null;
         }
         var feedIdOrApiKey = split[0];
         var channelName = split[1];
         
         return function(level, offset, successCallback) {
            var url = ESDR_API_ROOT_URL + "/feeds/" + feedIdOrApiKey + "/channels/" + channelName + "/tiles/" + level + "." + offset;
            console.log('getting ' + url);
            superagent.get(url)
                      .end(function(err, res) {
                         console.log('done getting ' + url);
                         if (err) {
                            return console.log("Error: " + res.body);
                         }
                         switch (res.status) {
                            case 200:
                               return successCallback(JSON.stringify(res.body.data));
                            case 401:
                               return console.log("Unauthorized");
                            case 403:
                               return console.log("Forbidden");
                            default:
                               return console.log("Error: " + res.body);
                         }
                      });
         };
      }

      var plotCount = 0;
      var channelLabels = {};
      var plotScalers = {};
      var channelToPlotIdx = {};
      var plotIdxToChannel = {};
      
      function addPlot(channel) {
         var html = [];
         html.push('<div style="height:100px; width:100%; position:relative; border-bottom:1px solid black">');
         var plotName = 'plot' + plotCount;
         var yAxisName = 'yaxis' + plotCount;
         html.push('<div id="' + plotName + '" style="position:absolute; left:0px; top:0px; bottom:0px; right:30px"></div>');
         html.push('<div id="' + yAxisName + '" style="position:absolute; width:30px; top:0px; bottom:0px; right:0px"></div>');
         html.push('<div style="position:absolute"><span style="cursor:pointer" onclick="removePlot(\'' + channel + '\')">â˜’</span> <font size=-1>' + channelLabels[channel] + '</font></div>');
         html.push('</div>');
         $('#plots').append(html.join(''));
         
         plotManager.addDataSeriesPlot(plotName, createDatasource(channel), plotName, yAxisName, 0, 100, style);
         var thisPlotIdx = plotCount;
         // TODO: Always polling to auto-scale the Y axis -- not ideal!
         // Someday, let's push this API to PlotManager and the actual implementation into the grapher.
         plotScalers[plotCount] = window.setInterval(function() {
            clampNumberAxisToDataRange(thisPlotIdx);
         }, 100);
         channelToPlotIdx[channel] = plotCount;
         plotIdxToChannel[plotCount] = channel;
         plotCount++;
         $('input[name="' + channel + '"]').prop('checked', true);

         var feedIndex = parseInt(channel.substr(0, channel.indexOf('.'))); 

         $("#channels div[id = '#" + feedIndex + "']").each(function(index, element){
            var inputTag = $(element).children().children().filter('input'); 

            if ($(inputTag).attr('name') == channel) $(element).prependTo('#channels'); 
         }); 

         changeColor(1,0,0, feedIndex);
      }

      function removePlot(channel) {
         var plotIdx = channelToPlotIdx[channel];
         var plotName = 'plot' + plotIdx;
         plotManager.getPlotContainer(plotName).removePlot(plotManager.getPlot(plotName));
         $('#plot' + plotIdx).parent().remove();
         window.clearInterval(plotScalers[plotIdx]);
         $('input[name="' + channel + '"]').prop('checked', false);

         var feedIndex = parseInt(channel.substr(0, channel.indexOf('.'))); 

         if (!(checkIfAnyChecked(feedIndex))) changeColor(0,0,1,feedIndex);

      }

      function clampNumberAxisToDataRange(plotIdx) {
         var plot = plotManager.getPlot('plot' + plotIdx);
         var yAxis = plotManager.getYAxis('yaxis' + plotIdx);
         var stats = plot.getStatisticsWithinRange(plotManager.getDateAxis().getRange());
         if (typeof stats['minValue'] !== 'undefined' && typeof stats['maxValue'] !== 'undefined') {
            yAxis.setRange(stats['minValue'], stats['maxValue']);
         }
      }

      function clickChannel(input) {
        console.log('clickChannel ' + input.name); 
        if (input.checked) {
          addPlot(input.name);
        } else {
          removePlot(input.name);
        }
        updateHash();
      } 

      function checkIfAnyChecked(index){
        
        var foundDivs = $("#channels div[id $= '#" + index + "']"); 

        var inputNodes = $(foundDivs).children().children().filter('input');
        var result = false; 
        $(inputNodes).each(function(){
          if ($(this).get(0).checked){
            result = true;
          } 
          console.log($(this).get(0).checked);
        });

        return result; 

      }

      function loadFeeds(response) {
         var data = response.data;
         var max = data.limit + data.offset;
         console.log('Received feeds in range ' + data.offset + ' - ' + max);
         if (data.totalCount > max) { 
           $.ajax({url: ESDR_API_ROOT_URL + '/feeds?offset=' + max, success: loadFeeds});
         }
         // TODO(rsargent): get all the feeds not just the first 1K
         var feeds = data.rows;
         var html = [];

         for (var i = 0; i < feeds.length; i++) {
            var feed = feeds[i]; 

            if (feed.channelBounds) {
               var channels = Object.keys(feed.channelBounds.channels).sort();

               if (channels.length > 0) {
                feedLocList.latlng.push(feed.latitude, feed.longitude); 
                feedLocList.index.push(feed.id);
                feedLocList.color.push(0, 0, 1, alpha);  
               }

               for (var c = 0; c < channels.length; c++) {
                  var channel = channels[c];
                  sortChannel(feed.productId, feed.id, channel); 
                  var label = feed.name + ' (' + feed.id + ').' + channel;
                  var id = feed.id + '.' + channel;
                  var idHashTag = feed.id; 
                  channelLabels[id] = label;
                  html.push('<div class="sensors" id="' + label.toLowerCase() + " #" + idHashTag + '"> <label> <input type="checkbox" onclick="clickChannel(this)" name="' + id +'">' + label + '<br></label></div>');
               }
            }
            //for (var channel = 0; i < feed.channelBounds.channels
         }
         $('#channels').append(html.join(''));
         if (data.totalCount <= max) {
            // That was the last data.  Ready to process
            loadHash();
            // TODO(rsargent): let's update this only when panning or zooming the time axis
            window.setInterval(updateHash, 100);
            window.onhashchange = loadHash; 

            feedLocList.latlng = new Float32Array(feedLocList.latlng); 
            feedLocList.index = new Float32Array(feedLocList.index); 
            feedLocList.color = new Float32Array(feedLocList.color); 

            $allSelect = $("div[class = sensors]"); 

            ($allSelect).each(function(){

                var currentNum = $(this).attr('id').substr($(this).attr('id').lastIndexOf('#') + 1); 
                
                if (currentNum == 4712) console.log('hi')
                if (allFeedNums.length == 0 || currentNum != allFeedNums[allFeedNums.length - 1]) {
                    allFeedNums.push(parseInt(currentNum));
                }
            });  
            
            initializeWebGL();  

         }

         searchAttributes(); 

      }

      // var pm25 = []; 
      // var pm10 = []; 
      // var ozone = []; 
      // var no = []; 
      // var no2 = []; 
      // var so2 = []; 
      // var co = []; 

      function sortChannel(productId, feedID, channel){
        if (productId == 1){
          console.log("ACHD Found"); 
          if (channel.indexOf("PM25") > -1){
            pm25.push(feedID); 
          }
          else if (channel.indexOf("PM10") > -1){
            pm10.push(feedID); 
          }
          else if (channel.indexOf("OZONE") > -1){
            ozone.push(feedID); 
          }
          else if (channel.indexOf("NO_") > -1){
            no.push(feedID);
          }
          else if (channel.indexOf("NO2_") > -1){
            no2.push(feedID);
          }
          else if (channel.indexOf("SO2") > -1){
            so2.push(feedID);
          }
          else if (channel.indexOf("CO_") > -1){
            co.push(feedID);
          }
        }else if(productId == 11){
          console.log("AirNow Found");
          if (channel.indexOf("PM2_5") > -1){
            pm25.push(feedID); 
          }
          else if (channel.indexOf("PM10") > -1){
            pm10.push(feedID); 
          }
          else if (channel.indexOf("OZONE") > -1){
            ozone.push(feedID); 
          }
          else if (channel.indexOf("NO2") > -1){
            no2.push(feedID);
          }
          else if (channel.indexOf("NO") > -1){
            no.push(feedID);
          }
          else if (channel.indexOf("SO2") > -1){
            so2.push(feedID);
          }
          else if (channel.indexOf("CO") > -1){
            co.push(feedID);
          }  
        }else if(productId == 35){
          console.log("BAAQMD Found");
          if (channel === "PM2_5"){
            pm25.push(feedID); 
          }
          else if (channel === "Ozone_O3"){
            ozone.push(feedID); 
          }
          else if (channel === "Nitrogen_Dioxide_NO2"){
            no2.push(feedID);
          }
          else if (channel === "Nitric_Oxide_NO"){
            no.push(feedID);
          }
          else if (channel === "Sulfur_Dioxide_SO2"){
            so2.push(feedID);
          }
          else if (channel === "Carbon_Monoxide_CO"){
            co.push(feedID);
          }
        }else if(productId == 9){
          console.log("Speck Found"); 
          speck.push(feedID); 
        }
        // }else if(feedName.indexOf("Speck") > -1){
        //   console.log("Speck Found");
        // }else if(feedName.indexOf("Retigo") > -1){
        //   console.log("Retigo Found");
        // }else if(feedName.indexOf("Tepper") > -1){
        //   console.log("Tepper Found");
        // }else if(feedName.indexOf("Rodeo") > -1){
        //   console.log("Rodeo Found");
        // }else if(feedName.indexOf("fenceline_org") > -1){
        //   console.log("fenceline_org Found");
        // }else{
        //   console.log("Other: " + channel);
        // }

        // switch (expression) {
        //   case value1:
        //     //Statements executed when the result of expression matches value1
        //     [break;]
        //   case value2:
        //     //Statements executed the result of expression matches value2
        //     [break;]
        //   ...
        //   case valueN:
        //     //Statements executed when the result of expression matches valueN
        //     [break;]
        //   default:
        //     //Statements executed when none of the values match the value of the expression
        //     [break;]
        // }

      }
      
      //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ init() function ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
      function init() {

         $.ajax({url: ESDR_API_ROOT_URL + '/feeds', success: loadFeeds});
         $('#search-bar').focus(); 

         $(document).on('click', function(event) {
            if (!$(event.target).closest('#search-bar').length) {
               $('#search-bar').blur(); 
            }
         }); 

         var timer = null; 
         $('#search-bar').keyup(function(){
            if ($('#search-bar').val() == ""){
               clearInterval(timer); 
               timer = null; 
               searchAttributes(); 
            }else if (timer == null) {
               timer = setTimeout(function(){
               searchAttributes()}, 100)}
         }).keydown(function(){
            if (timer) {
               clearInterval(timer);
               timer = null; 
            }
         }).click(function(){
            $(this).focus(); 

         }).on("search", function(){
            searchAttributes(); 
         }); 
      }

   //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ init() function END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      function getChannels() {
         var plotDivs = $('#plots [id^=plot]');
         var channels = [];
         for (var i = 0; i < plotDivs.length; i++) {
            var plotName = plotDivs[i].id;
            var plotIdx = parseInt(plotName.slice(4));
            var channel = plotIdxToChannel[plotIdx];
            channels.push(channel);
         }
         return channels;
      }
      
      function updateHash() {
         var channels = getChannels();
         var params = [];
         if (channels.length > 0) {
            params.push('channels=' + channels.join('|'));
         }
         var timeRange = plotManager.getDateAxis().getRange();
         params.push('time=' + timeRange.min + ',' + timeRange.max);
         var newHash = '#' + params.join('&');
         if (window.location.hash != newHash) {
            window.location.hash = newHash;
         }
      }

      // from http://stackoverflow.com/questions/4197591/parsing-url-hash-fragment-identifier-with-javascript
      function getHashParams() {
         var hashParams = {};
         var e,
             a = /\+/g,  // Regex for replacing addition symbol with a space
             r = /([^&;=]+)=?([^&;]*)/g,
             d = function (s) { return decodeURIComponent(s.replace(a, " ")); },
             q = window.location.hash.substring(1);
        
         while (e = r.exec(q)) hashParams[d(e[1])] = d(e[2]);
        
         return hashParams;
      }

      function loadHash() {
         var params = getHashParams();

         if (params.time) {
            var split = params.time.split(',');
            plotManager.getDateAxis().setRange(parseFloat(split[0]), parseFloat(split[1]));
         }

         var oldChannels = getChannels(); 
         var newChannels = [];
         if (params.channels) {
            newChannels = params.channels.split('|');
         }
         if (oldChannels.join('|') != newChannels.join('|')) {
            for (var i = 0; i < oldChannels.length; i++) {
               removePlot(oldChannels[i]);
            }
            for (i = 0; i < newChannels.length; i++) {
               addPlot(newChannels[i]);
            }
         }
      }

      function removePlot(channel) {
         var plotIdx = channelToPlotIdx[channel];
         var plotName = 'plot' + plotIdx;
         plotManager.getPlotContainer(plotName).removePlot(plotManager.getPlot(plotName));
         $('#plot' + plotIdx).parent().remove();
         window.clearInterval(plotScalers[plotIdx]);
         $('input[name="' + channel + '"]').prop('checked', false);

         var feedIndex = parseInt(channel.substr(0, channel.indexOf('.'))); 

         if (!(checkIfAnyChecked(feedIndex))) changeColor(0,0,1,feedIndex);
      }
      

      window.grapherLoad = function() {
         var maxTimeSecs = Date.now() / 1000;
         var minTimeSecs = maxTimeSecs - 7 * 24 * 60 * 60;

         plotManager = new org.bodytrack.grapher.PlotManager("date_axis", minTimeSecs, maxTimeSecs);

      plotManager.setWillAutoResizeWidth(true, function() {
               return $('#plots').width()         // window width
                      - 30;
            });
      }

      function searchAttributes() {
         var str = $('#search-bar').val().toLowerCase();     
         var wordList = str.split(" ") || [];
         showNumList = [];

        //  $('[name = filter]').each(function(index, input) {
        //     if (input.checked){
              
        //     }
        // });

         var showConditions = "[class = sensors]"; 
         for (var i = 0; i < wordList.length; i++){
            if (wordList[i] != "") {
               showConditions = showConditions + "[id *= '" + wordList[i] + "']";  
            }
         }; 

        $('div' + showConditions).each(function(){

          var currentNum = $(this).attr('id').substr($(this).attr('id').lastIndexOf('#') + 1); 

          if (showNumList.length == 0 || currentNum != showNumList[showNumList.length - 1]) {
            
            showNumList.push(parseInt(currentNum));

          } 

        })
         if (str == ""){
            if ($allSelect) {
              $allSelect.show(); 
              changeOpacity(allFeedNums, alpha)
            }
         } else {
            if($allSelect){
              $allSelect.hide(); 
              changeOpacity(allFeedNums, 0); 

              
              if (showNumList.length != 0){
                $('div' + showConditions).show(); 
                changeOpacity(showNumList, alpha)
              }//else{

              //   geocoder.geocode( { 'address': str}, function(results, status) {
              //     if (status == google.maps.GeocoderStatus.OK) { 
              //       var latlng = {latlng: []}
              //       console.log(results[0].geometry.viewport.northeast()); 
              //       // latlng.latlng.push(results[0].geometry.viewport);
              //       // latlng.xy = latlng.latlng;

              //       // for (var i = 0; i < latlng.latlng.length; i += 2) {
              //       //     var lat = latlng.latlng[i];
              //       //     var lon = latlng.latlng[i + 1];
              //       //     var pixel = LatLongToPixelXY(lat, lon);
              //       //     latlng.xy[i] = pixel.x;
              //       //     latlng.xy[i + 1] = pixel.y;
              //       // }
              //       // delete latlng.latlng;

              //       // var foundIndexes = []; 
              //       // for (var k = 0; k < feedLocList.index.length ; k++){
              //       //   if (Math.pow(feedLocList.xy[k*2] - latlng.xy[0],2) + Math.pow(feedLocList.xy[k*2 + 1] - latlng.xy[1],2) <= .05){
              //       //     foundIndexes.push(feedLocList.index[k]);
              //       //   }
              //       // } 

              //       // console.log(foundIndexes); 
              //       // changeOpacity(foundIndexes, alpha); 

              //     } else {
              //       console.log("Geocode was not successful for the following reason: " + status);
              //     }

              //   });

              // };
              
          }
         }; 

      }; 

      function printFoundDivs($divList){
        var string = ""; 
        $($divList).each(function(index, element){
          string += $(element).get(0).outerHTML; 
        })

        return string; 
      }

      $(init);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   WebGL START   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      var map;
      var geocoder;
      var canvasLayer;
      var gl;
      var pixelsToWebGLMatrix = new Float32Array(16);
      var mapMatrix = new Float32Array(16);
      var currentIndex, minIndex, maxIndex;

      function changeColor(r, g, b, feedNum){

        var listIndex = $.inArray(feedNum, feedLocList.index); 

        feedLocList.color[listIndex * 4 + 0] = r; 
        feedLocList.color[listIndex * 4 + 1] = g; 
        feedLocList.color[listIndex * 4 + 2] = b; 

        if(!!gl){
          gl.bindBuffer(gl.ARRAY_BUFFER, feedLocList.colorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, feedLocList.color, gl.STATIC_DRAW);

          // enable the 'aColor' attribute in the shader to receive buffer
          gl.enableVertexAttribArray(gl.getAttribLocation(feedLocList.program, 'aColor'));

          // tell webgl how buffer is laid out 
          gl.vertexAttribPointer(gl.getAttribLocation(feedLocList.program, 'aColor'), 4, gl.FLOAT, false, 0, 0);
        }

      }

      function changeOpacity(feedNumArray, alpha){

        $(feedNumArray).each(function(index, feedNum){

          var listIndex = $.inArray(feedNum, feedLocList.index); 

          feedLocList.color[listIndex * 4 + 3] = alpha; 

        })

        if(!!gl){gl.bindBuffer(gl.ARRAY_BUFFER, feedLocList.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, feedLocList.color, gl.STATIC_DRAW);

        // enable the 'aColor' attribute in the shader to receive buffer
        gl.enableVertexAttribArray(gl.getAttribLocation(feedLocList.program, 'aColor'));

        // tell webgl how buffer is laid out 
        gl.vertexAttribPointer(gl.getAttribLocation(feedLocList.program, 'aColor'), 4, gl.FLOAT, false, 0, 0);}

      }

      function initializeMap() {
            var myStyle = [
                            {
                              "featureType": "poi",
                              "elementType": "labels.icon",
                              "stylers": [
                                { "visibility": "on" }
                              ]
                            },
                            {
                              "featureType": "poi",
                              "elementType": "labels.text",
                              "stylers": [
                                { "visibility": "off" }
                              ]
                            }
                          ]

           var mapOptions = {
            // //start at middle of US
            // zoom: 4,
            // center: new google.maps.LatLng(39.3, -95.8)

            // start in Pittsburgh 
            zoom: 13,
            center: new google.maps.LatLng(40.442493, -79.942553),
            styles: myStyle, 

         };
         
         map = new google.maps.Map(document.getElementById('map-div'),
            mapOptions);

         geocoder = new google.maps.Geocoder();

      }

      google.maps.event.addDomListener(window, 'load', initializeMap); 

      function codeAddress(address) {
        
      }

      function drawFrame() {
        gl.enable(gl.BLEND);
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

        // Compute WebGL transform from world xy coords to screen
        // copy pixel->webgl matrix
        mapMatrix.set(pixelsToWebGLMatrix);

        var scale = canvasLayer.getMapScale();
        scaleMatrix(mapMatrix, scale, scale);

        var translation = canvasLayer.getMapTranslation();
        translateMatrix(mapMatrix, translation.x, translation.y);

        // Erase frame
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Compute point diameter, in pixels, based on zoom level

        // map.zoom is approx 4 at country level
        var countryPointSizePixels = 5;

        // map.zoom is approx 18 at block level
        var blockPointSizePixels = 50;

        var pointSize = .75 * countryPointSizePixels * Math.pow(blockPointSizePixels / countryPointSizePixels, (map.zoom - 4) / (18 - 4));

        currentPointSize = pointSize; 

        var color = [0, 0, 255, alpha];

        var hardFraction = .90;  

        var count = feedLocList.index.length;

        drawPoints(gl, mapMatrix, feedLocList, 0, count, 
                   {color: color, pointSize: pointSize, hardFraction: hardFraction}); 
      }

      //for implementation of WebGL
      function initWebGL() {
        // initialize the canvasLayer
        var canvasLayerOptions = {
          map: map,
          resizeHandler: resize,
          animate: true,
          updateHandler: drawFrame
        };
        canvasLayer = new CanvasLayer(canvasLayerOptions);

        window.addEventListener('resize', function(){ google.maps.event.trigger(map, 'resize') }, false);

        // initialize WebGL
        gl = canvasLayer.canvas.getContext('experimental-webgl');
        return !!gl;
      }

      function resize() {
        var w = canvasLayer.canvas.width;
        var h = canvasLayer.canvas.height;

        // Extend viewport to entire canvas
        gl.viewport(0, 0, w, h);

        // Map canvas pixel coordinates to WebGL coordinates
        pixelsToWebGLMatrix.set([2/w, 0,   0, 0,
                                 0,  -2/h, 0, 0,
                                 0,   0,   1, 0,
                                -1,   1,   0, 1]);
      }

      //When ready to draw points 
      function initializeWebGL(){

         if (!initWebGL()) {
             $('#map-div').append('<div align="center" style="position: absolute; z-index:1000000; margin:50px; padding:10px; border-color:black; border-style:solid; border-width:1px; box-shadow:5px 5px 5px grey; background-color:white; font-size:20px"><b>WebGL required</b><br>Please try using a browser that supports WebGL,<br>such as Chrome, Firefox, or Internet Explorer 11.</div>');
           }

          // Convert from latlng to xy for map, and set up shader programs
         prepareSeries(gl, feedLocList);

         currentIndex = minIndex = feedLocList.index[0];
         maxIndex = feedLocList.index[feedLocList.index.length - 1];

         var infoWindow; 
         google.maps.event.addListener(map, 'click', function(event) {
                var finalDiv = $('<div></div>'); 
                var finalInput = $('<div></div>'); 
                var sectionBreak = $('<hr>');
                var meanLat = 0; 
                var meanLng = 0; 
                var maxDistInPixels = currentPointSize/2 + 10;
                var eltList = findClosestElement(gl, mapMatrix, feedLocList, event.pixel, maxDistInPixels);
                var inputNodes = null; 
                for (var i = 0; i < eltList.length; i++){

                   if (feedLocList.color[eltList[i].i * 4 + 3] != 0) {

                    console.log("Feed Number: " + feedLocList.index[eltList[i].i] + ", Location in Array: " + eltList[i].i);

                    var clickedNode = null; 
                    
                    clickedNode = $("#channels div[id $= '#" + feedLocList.index[eltList[i].i] + "']");
                    inputNodes = $(clickedNode).children().children().filter('input');

                    $(finalInput).append(inputNodes.clone()); 

                    console.log(finalDiv);

                    if(i > 0 && i < eltList.length)$(finalDiv).append(sectionBreak.clone());
                    $(finalDiv).append(clickedNode.clone()); 
                    $('input[name="' + $(this).attr('name') + '"]').prop('checked', $(this).prop('checked'));
                    
                    meanLat += eltList[i].lat/eltList.length; 
                    meanLng += eltList[i].lng/eltList.length; 
                  }
                     
              }

              if (eltList.length != 0){
                  if (infoWindow){
                    infoWindow.close();
                  };

                 infoWindow = new google.maps.InfoWindow(
                      {content: printFoundDivs(finalDiv), 
                      position: new google.maps.LatLng(meanLat, meanLng)});
                  infoWindow.open(map); 

                  google.maps.event.addListener(infoWindow, 'domready', function() {
                    $(finalInput).children().each(function (index, inputs){
                      $('input[name="' + $(this).attr('name') + '"]').prop('checked', $(this).prop('checked'));
                    }); 
                  });
              };
         });

          google.maps.event.addListener(map, 'mousemove', function(event) {
                var maxDistInPixels = currentPointSize/2 + 1 / (currentPointSize + .00001) ;
                var eltList = findClosestElement(gl, mapMatrix, feedLocList, event.pixel, maxDistInPixels);
                for (var i = 0; i < eltList.length; i++){
                    if (feedLocList.color[eltList[i].i * 4 + 3] != 0) {
                      map.setOptions({ draggableCursor: 'default' });
                      changeOpacity([feedLocList.index[eltList[i].i]], 1); 
                    } 
                }

                if (eltList.length == 0){
                    map.setOptions({ draggableCursor: null });
                    changeOpacity(showNumList, alpha);
                }
          });
      }

</script>

</script>

    <script id="pointVertexShader" type="x-shader/x-vertex">
      attribute vec4 worldCoord;
      attribute float aPointSize;
      attribute vec4 aColor; 

      varying vec4 vColor; 

      uniform mat4 mapMatrix;

      void main() {
        // transform world coordinate by matrix uniform variable
        gl_Position = mapMatrix * worldCoord;

        // a constant size for points, regardless of zoom level
        gl_PointSize = aPointSize;

        vColor = aColor; 
      }
    </script>
    <script id="pointFragmentShader" type="x-shader/x-fragment">
      precision mediump float;
      uniform vec4 color;
      varying vec4 vColor; 

      uniform float hardFraction;

      // Circle of diameter 0.5, composed of a "hard" (alpha=1) center of radius 0.5 * hardFraction,
      // then transitioning to alpha=0 at diameter 0.5
      void main() {
        float dist = length(gl_PointCoord.xy - vec2(.5, .5));
        // TODO(rsargent):  shouldn't we just be adjusting the alpha here?  Maybe we're taking
        // advantage of the double-multiplication to get something other than linear.
        // But multiplying all the channels will break if we do something other than an additive blend.
        // gl_FragColor = color * clamp((0.5 - dist) / (0.5 - 0.5 * hardFraction), 0., 1.);

        //gl_FragColor = vColor * clamp((0.5 - dist) / (0.5 - 0.5 * hardFraction), 0., 1.);
        
        gl_FragColor = vColor * clamp((.5 - dist) / (0.5 - 0.5 * hardFraction), 0., 1.);

      }
    </script>

</head>
<body style="width:100%;height:100%">
<input id = "search-bar" type = "search" placeholder="Search: " style = "width:19%; height:15px; position:absolute; left:3px; top: 5px; font-size:10px;"> 
<form id = "filters" style="font-size:12px; position: absolute; width: 200px; height: 160px; top: 25px; left: 3px; background-color: white;">
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">PM2.5<br></label>
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">PM10<br></label>
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">Ozone (O<sub>3</sub>)<br></label>
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">Nitric Oxide (NO)<br></label>
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">Nitrogen Dioxide (NO<sub>2</sub>)<br></label>
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">Sulfur Dioxide (SO<sub>2</sub>)<br></label>
  <label><input type="checkbox" name="filter" onclick="searchAttributes()">Carbon Monoxide (CO)<br></label>
  <input type="reset" value="Clear Filters">
</form>
<div id="channels" style="width:20%; height:calc(100vh - 190px); position:absolute; left:0px; top:180px; font-size:10px; overflow-y:auto"></div>
<div id="map-div" style="width:80%; height:40%; position:absolute; right:3px;"></div>
<div id="charts" style="width:80%; height: 60%; position:absolute; right:0px; bottom:0px;">
  <div style="position:relative; height: 50px; width:100%; border-bottom:1px solid black">
      <div id="date_axis" style="position:absolute; top:0px; bottom:0px; left:0px; right:40px"></div>
  </div>
  <div id = "plots" style="position:relative; overflow-y: auto; top:0px; height:calc(60vh - 50px);">
</div>
</body>
</html>


