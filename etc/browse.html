<!DOCTYPE HTML>
<html>
<head>
   <title>Browse ESDR</title>
   <meta http-equiv="content-type" content="text/html;charset=utf-8" />
   <style type="text/css">
      body {
         font-family: 'Open Sans', 'Helvetica', sans-serif !important;
         font-weight: 400 !important;
         font-size: 16px !important;
         margin: 3px;
         width: 100%;
         height: 100%;
         overflow-y: hidden;
      }

      .plot_container {
         position: relative;
         border: 1px solid black;
      }

      .plot_container > canvas:focus {
         outline: none;
      }

      .date_axis {
         height: 42px;
         z-index: 2;
         border: 1px solid black;
         border-bottom-width: 0;
      }

      .y_axis {
         position: relative;
         width: 42px;
         border: 1px solid black;
         border-left-width: 0;
      }

      .y_axis_label {
         position: absolute;
         text-align: center;
         font-size: 8pt;
         height: auto;
      }

      .rotate_90 {
         transform: rotate(90deg);
         -ms-transform: rotate(90deg);
         -webkit-transform: rotate(90deg);
      }

      #channel_switcher_panel {
         text-align: center;
         margin-top: 10px;
         margin-bottom: 20px;
         font-size: smaller;
      }

      .channel_link, .time_range_link {
         display: inline-block;
         margin-left: 10px;
         margin-right: 10px;
         cursor: pointer;
      }

      #time_range_switcher_panel {
         text-align: center;
         margin-top: 10px;
         margin-bottom: 20px;
         font-size: smaller;
      }

      #value_and_time {
         position: absolute;
         display: none;
         top: 2px;
         right: 2px;
         background-color: rgba(255, 255, 255, 0.9);
         margin: 2px;
         padding: 2px;
         font-size: 11px;
         line-height: 11px;
      }
   </style>

   <script src="https://esdr.cmucreatelab.org/lib/jquery/jquery-1.11.1.min.js" type="text/javascript"></script>
   <script src="https://esdr.cmucreatelab.org/lib/superagent/superagent.js" type="text/javascript"></script>
   <script src="https://esdr.cmucreatelab.org/lib/bodytrack-grapher/org/bodytrack/grapher/grapher2.nocache.js" type="text/javascript"></script>
   <script src="https://esdr.cmucreatelab.org/lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>

   <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
   <script src="http://api.cmucreatelab.org/exp-0.1/js/utils.js"></script>
   <script src="..\series2.js"></script> 
   <script src="http://api.cmucreatelab.org/exp-0.1/js/CanvasLayer.js"></script>

   <script language="JavaScript" type="text/javascript">

      //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   esdr start  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      var feedLocList = {latlng: [], index: [], color: []}; 
      var ESDR_API_ROOT_URL = 'https://esdr.cmucreatelab.org/api/v1';
      var DEFAULT_CHANNEL = 'particle_concentration';

      var selectedFeedIdOrApiKey = null;
      var selectedChannelName = null;

      var channelUnits = null;

      var showNumList = [];
      var clickedNumList = [];  

      var pm25 = []; 
      var pm10 = []; 
      var ozone = []; 
      var no = []; 
      var no2 = []; 
      var so2 = []; 
      var co = []; 
      var speck = []; 

      //Jquery cache for all selectors 
      //var $allSelect = null; 

      var allFeedNums = []; 
      var channelNames = {pm25: [], pm10: [], ozone: [], no: [], no2: [], so2: [], co: []};

      // grapher stuff
      var plotManager;
      var feed = null;
      var availableChannels = [];
      var isAutoScaleOn = false;
      var hashTimer; 

      //Timeline Stuff
      var DEFAULT_SPEED = 35; 
      var DEFAULT_DURATION = 15;

      //WebGL stuff
      var alpha = 0.65; 
      var currentPointSize = 0; 

      function setRangeFromSecondsAgoToNow(numSecondsAgo) {
         var now = Date.now() / 1000;
         var min = now - numSecondsAgo;
         plotManager.getDateAxis().constrainRangeTo(Math.min(min, feed.minTimeSecs), now);
         plotManager.getDateAxis().setRange(min, now);
      }

      var timeRangeOptions = [
         {
            "label" : "all data",
            "handler" : function() {
               plotManager.getDateAxis().setRange(feed.minTimeSecs, feed.maxTimeSecs);
            }
         },
         {
            "label" : "past 30 days",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*24*30);
            }
         },
         {
            "label" : "past 7 days",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*24*7);
            }
         },
         {
            "label" : "past 24 hours",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*24);
            }
         },
         {
            "label" : "past 12 hours",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600*12);
            }
         },
         {
            "label" : "past hour",
            "handler" : function() {
               setRangeFromSecondsAgoToNow(3600);
            }
         },
      ];

      function setTimeRange(rangeName) {
         var rangeFunction = timeRangeOptions[rangeName];
         if (typeof rangeFunction === 'function') {
            var range = rangeFunction();
            if (range && 'min' in range && 'max' in range) {
               plotManager.getDateAxis().setRange(range['min'], range['max']);
            }
         }
      }

      // Got this from: http://css-tricks.com/snippets/javascript/get-url-variables/
      function getQueryVariable(variable) {
         var query = window.location.search.substring(1);
         var vars = query.split("&");
         for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            if (pair[0] == variable) {
               return pair[1];
            }
         }
         return null;
      }

      var style = {
         "styles" : [
            // { "type" : "line", "lineWidth" : 1, "show" : true, "color" : "red" },
            // { "type" : "circle", radius : 3, "lineWidth" : 1, "show" : true, "color" : "blue", fill : false }
            {
                     "type" : "bar",
                     "stripPosition" : "center",
                     "stripWidthSecs" : 3600,
                     // "rangedColors" : "rgb(0,255,0); 3;rgb(47,255,0); 6;rgb(110,255,0); 9;rgb(180,255,0); 12;rgb(255,255,0); 15;rgb(255,177,0);18;rgb(255,107,0);21;rgb(255,46,0);24;rgb(255,0,0)"
                     "rangedColors" : "rgb(230,230,230); 8;rgb(210,210,210); 16;rgb(190,190,190); 24;rgb(170,170,170); 32;rgb(150,150,150); 40;rgb(130,130,130);48;rgb(110,110,110);56;rgb(90,90,90);64;rgb(70,70,70)"
                  },
            //{ "type" : "line", "lineWidth" : 1, "show" : true, "color" : "light gray"}
         ],
         "highlight" : {
            "lineWidth" : 1,
            "styles" : [
               {
                  "show" : true,
                  "type" : "lollipop",
                  "color" : "green",
                  "radius" : 0,
                  "lineWidth" : 1,
                  "fill" : false
               },
               {
                  "type" : "circle",
                  radius : 3,
                  "lineWidth" : 0.5,
                  "show" : true,
                  "color" : "#ff0000",
                  fill : true
               },
               {
                  "show" : true,
                  "type" : "value",
                  "fillColor" : "#000000",
                  "marginWidth" : 10,
                  "font" : "9pt Helvetica,Arial,Verdana,sans-serif",
                  "verticalOffset" : 7
               }
            ]
         }
      };

      function createDatasource(source) {
         var split = source.split('.');
         if (split.length != 2) {
            console.log('createDatasource must have source of form ID.channel but was ' + source);
            return null;
         }
         var feedIdOrApiKey = split[0];
         var channelName = split[1];
         
         return function(level, offset, successCallback) {
            var url = ESDR_API_ROOT_URL + "/feeds/" + feedIdOrApiKey + "/channels/" + channelName + "/tiles/" + level + "." + offset;
            console.log('getting ' + url);
            superagent.get(url)
                      .end(function(err, res) {
                         console.log('done getting ' + url);
                         if (err) {
                            return console.log("Error: " + res.body);
                         }
                         switch (res.status) {
                            case 200:
                               return successCallback(JSON.stringify(res.body.data));
                            case 401:
                               return console.log("Unauthorized");
                            case 403:
                               return console.log("Forbidden");
                            default:
                               return console.log("Error: " + res.body);
                         }
                      });
         };
      }

      var plotCount = 0;
      var channelLabels = {};
      var plotScalers = {};
      var channelToPlotIdx = {};
      var plotIdxToChannel = {};
      
      function addPlot(channel) {
         var html = [];
         html.push('<div style="height:100px; width:100%; position:relative; border-bottom:1px solid black">');
         var plotName = 'plot' + plotCount;
         var yAxisName = 'yaxis' + plotCount;
         html.push('<div id="' + plotName + '" style="position:absolute; left:0px; top:0px; bottom:0px; right:30px"></div>');
         html.push('<div id="' + yAxisName + '" style="position:absolute; width:30px; top:0px; bottom:0px; right:0px"></div>');
         html.push('<div style="position:absolute"><span style="cursor:pointer" onclick="removePlot(\'' + channel + '\')">☒</span> <font size=-1>' + channelLabels[channel] + '</font></div>');
         html.push('</div>');
         $('#plots').append(html.join(''));
         
         plotManager.addDataSeriesPlot(plotName, createDatasource(channel), plotName, yAxisName, 0, 100, style);
         var thisPlotIdx = plotCount;
         // TODO: Always polling to auto-scale the Y axis -- not ideal!
         // Someday, let's push this API to PlotManager and the actual implementation into the grapher.
         plotScalers[plotCount] = window.setInterval(function() {
            clampNumberAxisToDataRange(thisPlotIdx);
         }, 100);
         channelToPlotIdx[channel] = plotCount;
         plotIdxToChannel[plotCount] = channel;
         plotCount++;
         $('input[name="' + channel + '"]').prop('checked', true);

         var feedIndex = parseInt(channel.substr(0, channel.indexOf('.'))); 

         changeColor(75,0,130, feedIndex);
         updateHash()
      }

      function removePlot(channel) {
         var plotIdx = channelToPlotIdx[channel];
         var plotName = 'plot' + plotIdx;
         plotManager.getPlotContainer(plotName).removePlot(plotManager.getPlot(plotName));
         $('#plot' + plotIdx).parent().remove();
         window.clearInterval(plotScalers[plotIdx]);
         $('input[name="' + channel + '"]').prop('checked', false);

         var feedIndex = parseInt(channel.substr(0, channel.indexOf('.'))); 

         if (!(checkIfAnyChecked(feedIndex))) changeColor(0,0, 255,feedIndex);

      }

      function clampNumberAxisToDataRange(plotIdx) {
         var plot = plotManager.getPlot('plot' + plotIdx);
         var yAxis = plotManager.getYAxis('yaxis' + plotIdx);
         var stats = plot.getStatisticsWithinRange(plotManager.getDateAxis().getRange());
         if (typeof stats['minValue'] !== 'undefined' && typeof stats['maxValue'] !== 'undefined') {
            yAxis.setRange(stats['minValue'], stats['maxValue']);
         }
      }

      function clickChannel(input) {
        console.log('clickChannel ' + input.name); 
        if (input.checked) {
          addPlot(input.name);
        } else {
          removePlot(input.name);
        }
      } 

      function checkIfAnyChecked(index){
        
        var foundDivs = $("#channels div[id $= '#" + index + "']"); 

        var inputNodes = $(foundDivs).children().children().filter('input');
        var result = false; 
        $(inputNodes).each(function(){
          if ($(this).get(0).checked){
            result = true;
          } 
          console.log($(this).get(0).checked);
        });

        return result; 

      }

      function loadFeeds(response) {
         var data = response.data;
         var max = data.limit + data.offset;
         console.log('Received feeds in range ' + data.offset + ' - ' + max);
         if (data.totalCount > max) { 
           $.ajax({url: ESDR_API_ROOT_URL + '/feeds?offset=' + max, success: loadFeeds});
         }
         // TODO(rsargent): get all the feeds not just the first 1K
         var feeds = data.rows;
         var html = [];

         for (var i = 0; i < feeds.length; i++) {
            var feed = feeds[i]; 

            if (feed.channelBounds) {
               var channels = Object.keys(feed.channelBounds.channels).sort();

               if (channels.length > 0) {
                feedLocList.latlng.push(feed.latitude, feed.longitude); 
                feedLocList.index.push(feed.id);
                feedLocList.color.push(0, 0, 1, alpha);  
               }

               for (var c = 0; c < channels.length; c++) {
                  var channel = channels[c];
                  var channelId = sortChannel(feed.productId, feed.id, channel); 
                  var label = feed.name + ' (' + feed.id + ').' + channel;
                  var id = feed.id + '.' + channel;
                  var idHashTag = feed.id; 
                  channelLabels[id] = label;
                  html.push('<div class="sensors" data-channel-type="' + channelId + '" id="' + label.toLowerCase() + " #" + idHashTag + '"> <label> <input type="checkbox" onclick="clickChannel(this)" name="' + id +'">' + label + '<br></label></div>');
               }
            }
            //for (var channel = 0; i < feed.channelBounds.channels
         }
         $('#channels').append(html.join(''));
         if (data.totalCount <= max) {
            // That was the last data.  Ready to process
            loadHash();
            // TODO(rsargent): let's update this only when panning or zooming the time axis
            // window.setInterval(updateHash, 100);
            window.onhashchange = loadHash; 

            feedLocList.latlng = new Float32Array(feedLocList.latlng); 
            feedLocList.index = new Float32Array(feedLocList.index); 
            feedLocList.color = new Float32Array(feedLocList.color); 

            

            $("div[class = sensors]").each(function(){

                var currentNum = $(this).attr('id').substr($(this).attr('id').lastIndexOf('#') + 1); 
                
                if (currentNum == 4712) console.log('hi')
                if (allFeedNums.length == 0 || currentNum != allFeedNums[allFeedNums.length - 1]) {
                    allFeedNums.push(parseInt(currentNum));
                }
            });  
            
            initializeWebGL();  

         }

         searchAttributes(); 

      }

      function sortChannel(productId, feedID, channel){
        if (productId == 1){
          //console.log("ACHD Found"); 
          if (channel.indexOf("PM25") > -1){
            if (pm25[pm25.length - 1] != feedID) pm25.push(feedID), channelNames.pm25.push(channel);
            return "pm25";  
          }
          else if (channel.indexOf("PM10") > -1){
            if (pm10[pm10.length - 1] != feedID) pm10.push(feedID), channelNames.pm10.push(channel);
            return "pm10"; 
          }
          else if (channel.indexOf("OZONE") > -1){
            if (ozone[ozone.length - 1] != feedID) ozone.push(feedID), channelNames.ozone.push(channel);
            return "ozone";  
          }
          else if (channel.indexOf("NO_") > -1){
            if (no[no.length - 1] != feedID) no.push(feedID), channelNames.no.push(channel);
            return "no"; 
          }
          else if (channel.indexOf("NO2_") > -1){
            if (no2[no2.length - 1] != feedID) no2.push(feedID), channelNames.no2.push(channel);
            return "no2"; 
          }
          else if (channel.indexOf("SO2") > -1){
            if (so2[so2.length - 1] != feedID) so2.push(feedID), channelNames.so2.push(channel);
            return "so2"; 
          }
          else if (channel.indexOf("CO_") > -1){
            if (co[co.length - 1] != feedID) co.push(feedID), channelNames.co.push(channel);
            return "co"; 
          }
        }else if(productId == 11){
          //console.log("AirNow Found");
          if (channel.indexOf("PM2_5") > -1){
            if (pm25[pm25.length - 1] != feedID) pm25.push(feedID), channelNames.pm25.push(channel);
            return "pm25";  
          }
          else if (channel.indexOf("PM10") > -1){
            if (pm10[pm10.length - 1] != feedID) pm10.push(feedID), channelNames.pm10.push(channel);
            return "pm10";  
          }
          else if (channel.indexOf("OZONE") > -1){
            if (ozone[ozone.length - 1] != feedID) ozone.push(feedID), channelNames.ozone.push(channel);
            return "ozone"; 
          }
          else if (channel.indexOf("NO2") > -1){
             if (no2[no2.length - 1] != feedID) no2.push(feedID), channelNames.no2.push(channel);
            return "no2"; 
          }
          else if (channel.indexOf("NO") > -1){
            if (no[no.length - 1] != feedID) no.push(feedID), channelNames.no.push(channel);
            return "no"; 
          }
          else if (channel.indexOf("SO2") > -1){
            if (so2[so2.length - 1] != feedID) so2.push(feedID), channelNames.so2.push(channel);
            return "so2"; 
          }
          else if (channel.indexOf("CO") > -1){
            if (co[co.length - 1] != feedID) co.push(feedID), channelNames.co.push(channel);
            return "co"; 
          }  
        }else if(productId == 35){
          //console.log("BAAQMD Found");
          if (channel === "PM2_5"){
            if (pm25[pm25.length - 1] != feedID) pm25.push(feedID), channelNames.pm25.push(channel);
            return "pm25";  
          }
          else if (channel === "Ozone_O3"){
            if (ozone[ozone.length - 1] != feedID) ozone.push(feedID), channelNames.ozone.push(channel); 
            return "ozone"; 
          }
          else if (channel === "Nitrogen_Dioxide_NO2"){
            if (no2[no2.length - 1] != feedID) no2.push(feedID), channelNames.no2.push(channel);
            return "no2"; 
          }
          else if (channel === "Nitric_Oxide_NO"){
            if (no[no.length - 1] != feedID) no.push(feedID), channelNames.no.push(channel);
            return "no"; 
          }
          else if (channel === "Sulfur_Dioxide_SO2"){
            if (so2[so2.length - 1] != feedID) so2.push(feedID), channelNames.so2.push(channel);
            return "so2"; 
          }
          else if (channel === "Carbon_Monoxide_CO"){
            if (co[co.length - 1] != feedID) co.push(feedID), channelNames.co.push(channel);
            return "co"; 
          }
        }else if(productId == 9){
          //console.log("Speck Found"); 
          speck.push(feedID); 
          return "speck"; 
        }
        // }else if(feedName.indexOf("Speck") > -1){
        //   console.log("Speck Found");
        // }else if(feedName.indexOf("Retigo") > -1){
        //   console.log("Retigo Found");
        // }else if(feedName.indexOf("Tepper") > -1){
        //   console.log("Tepper Found");
        // }else if(feedName.indexOf("Rodeo") > -1){
        //   console.log("Rodeo Found");
        // }else if(feedName.indexOf("fenceline_org") > -1){
        //   console.log("fenceline_org Found");
        else{
          //console.log("Other Found");
          return "other"; 
        }
        return "other"; 
      }

      function prepareJSON(){
        var pm25Array = [];
        var index = 0; 
        var alreadySorted = [];

        while(index < channelNames.pm25.length){
          if (alreadySorted.indexOf(index) == -1){
            var sameChannelName = []; 
            var checkValue = channelNames.pm25[index];
            var idx = channelNames.pm25.indexOf(checkValue); 
            while (idx != -1){
              sameChannelName.push(idx);
              alreadySorted.push(idx);
              idx = channelNames.pm25.indexOf(checkValue, idx + 1); 
            }
            pm25Array.push(sameChannelName);
          }
          index++;
        }

        var pm25JSON = {name:"pm_25", spec:[]}; 
        
        for(var i = 0; i < pm25Array.length; i++){
          var feedString = "whereOr="; 
          console.log(pm25Array[i].length);
          for (var k = 0; k < pm25Array[i].length; k++){
            feedString += "id=" + pm25[pm25Array[i][k]] + ",";
          }
          feedString = feedString.substring(0, feedString.length - 1);
          pm25JSON.spec.push({feeds: feedString, channels: [channelNames.pm25[pm25Array[i][0]]]});  
        }

        console.log(JSON.stringify(pm25JSON));
      }
      
      //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ init() function ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
      function init() {

         $.ajax({url: ESDR_API_ROOT_URL + '/feeds', success: loadFeeds});
         $('#search-bar').focus(); 

         $(document).on('click', function(event) {
            if (!$(event.target).closest('#search-bar').length) {
               $('#search-bar').blur(); 
            }
         }); 

         var timer = null; 
         $('#search-bar').keyup(function(){
            if ($('#search-bar').val() == ""){
               clearInterval(timer); 
               timer = null; 
               searchAttributes(); 
            }else if (timer == null) {
               timer = setTimeout(function(){
               searchAttributes()}, 100)}
         }).keydown(function(){
            if (timer) {
               clearInterval(timer);
               timer = null; 
            }
         }).click(function(){
            $(this).focus(); 

         }).on("search", function(){
            searchAttributes(); 
         }); 

         $('#duration').change(function(){
            setSpeed();
         })
      }

   //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ init() function END ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      function getChannels() {
         var plotDivs = $('#plots [id^=plot]');
         var channels = [];
         for (var i = 0; i < plotDivs.length; i++) {
            var plotName = plotDivs[i].id;
            var plotIdx = parseInt(plotName.slice(4));
            var channel = plotIdxToChannel[plotIdx];
            channels.push(channel);
         }
         return channels;
      }
      
      function updateHash() {
         var channels = getChannels();
         var params = [];
         if (channels.length > 0) {
            params.push('channels=' + channels.join('|'));
         }
         var timeRange = plotManager.getDateAxis().getRange();
         params.push('time=' + timeRange.min + ',' + timeRange.max);
         var newHash = '#' + params.join('&');
         if (window.location.hash != newHash) {
            window.location.hash = newHash;
         }
      }

      // from http://stackoverflow.com/questions/4197591/parsing-url-hash-fragment-identifier-with-javascript
      function getHashParams() {
         var hashParams = {};
         var e,
             a = /\+/g,  // Regex for replacing addition symbol with a space
             r = /([^&;=]+)=?([^&;]*)/g,
             d = function (s) { return decodeURIComponent(s.replace(a, " ")); },
             q = window.location.hash.substring(1);
        
         while (e = r.exec(q)) hashParams[d(e[1])] = d(e[2]);
        
         return hashParams;
      }

      function loadHash() {
         var params = getHashParams();

         if (params.time) {
            var split = params.time.split(',');
            plotManager.getDateAxis().setRange(parseFloat(split[0]), parseFloat(split[1]));
         }

         var oldChannels = getChannels(); 
         var newChannels = [];
         if (params.channels) {
            newChannels = params.channels.split('|');
         }
         if (oldChannels.join('|') != newChannels.join('|')) {
            for (var i = 0; i < oldChannels.length; i++) {
               removePlot(oldChannels[i]);
            }
            for (i = 0; i < newChannels.length; i++) {
               addPlot(newChannels[i]);
            }
         }
      }

      function removePlot(channel) {
         var plotIdx = channelToPlotIdx[channel];
         var plotName = 'plot' + plotIdx;
         plotManager.getPlotContainer(plotName).removePlot(plotManager.getPlot(plotName));
         $('#plot' + plotIdx).parent().remove();
         window.clearInterval(plotScalers[plotIdx]);
         $('input[name="' + channel + '"]').prop('checked', false);

         var feedIndex = parseInt(channel.substr(0, channel.indexOf('.'))); 

         if (!(checkIfAnyChecked(feedIndex))) changeColor(0,0,255,feedIndex);
         updateHash();
      }
      

      window.grapherLoad = function() {
         var maxTimeSecs = Date.now() / 1000;
         var minTimeSecs = maxTimeSecs - 7 * 24 * 60 * 60;

         plotManager = new org.bodytrack.grapher.PlotManager("date_axis", minTimeSecs, maxTimeSecs);

         plotManager.setWillAutoResizeWidth(true, function() {
                 return $('#plots').width()         // window width
                        - 30;
              });

         dateProperties = plotManager.getDateAxis().getRange();

         //Fires when cursor position changes or date axis bound changes 
         plotManager.getDateAxis().addAxisChangeListener(function(dateAxisProperties) { 
            if (timelineReady 
                && ((Math.abs(dateAxisProperties.max - dateAxisProperties.min - dateProperties.max + dateProperties.min) >= Number.EPSILON)
                || (dateAxisProperties.max > timelineQueue[timelineQueue.length - 1].timeStamp && dateAxisProperties.max < maxTimeSecs)
                || (dateAxisProperties.min < timelineQueue[0].timeStamp))){
                pauseTimeline();
                clearTimeout(hashTimer);
                hashTimer = setTimeout(updateHash, 1000);
                $('#play').attr('disabled','disabled');
                timelineReady = false;
                clearTimeout(refreshTimer);
                refreshTimer = setTimeout(function() {
                  updateMultifeed(dateAxisProperties.min, dateAxisProperties.max); 
                }, 500);

              if(playing) showColorAtIndex(findIndexAtTime(timelineQueue, dateAxisProperties.cursorPosition));
            }

            if (Math.abs(dateProperties.cursorPosition - dateAxisProperties.cursorPosition) >= Number.EPSILON)
              showColorAtIndex(findIndexAtTime(timelineQueue, dateAxisProperties.cursorPosition));

            if (dateAxisProperties.cursorPosition > Date.now()/1000){
                  $('#play').attr('disabled','disabled');
            }else{
              if (timelineReady){
                $('#play').removeAttr('disabled');
              }
            }

            dateProperties = dateAxisProperties;
        });
        
      }

      function searchAttributes() {
         var str = $('#search-bar').val().toLowerCase();     
         var wordList = str.split(" ") || [];
         showNumList = [];
         var filterNumList = [];


         var showConditions = "div[class = sensors]"; 
         for (var i = 0; i < wordList.length; i++){
            if (wordList[i] != "") {
               showConditions += "[id *= '" + wordList[i] + "']";  
            }
         }; 

         var finalSearchConditions = ""; 
         var noneChecked = true; 
         $('#filters [type = checkbox]').each(function(index, input) {
            if (input.checked){
              noneChecked = false; 
              switch (input.name) {
                  case "pm25":
                    filterNumList = filterNumList.concat(pm25);
                    console.log("pm25 checked"); 
                    finalSearchConditions += showConditions + "[data-channel-type = 'pm25'],"; 
                    break;
                  case "pm10":
                    filterNumList = filterNumList.concat(pm10);
                    console.log("pm10 checked"); 
                    finalSearchConditions += showConditions + "[data-channel-type = 'pm10'],"; 
                    break;
                  case "ozone":
                    filterNumList = filterNumList.concat(ozone);
                    console.log("ozone checked"); 
                    finalSearchConditions += showConditions + "[data-channel-type = 'ozone'],"; 
                    break;
                  case "no":
                    filterNumList = filterNumList.concat(no);
                    console.log("no checked");
                    finalSearchConditions += showConditions + "[data-channel-type = 'no'],"; 
                    break;
                  case "no2":
                    filterNumList = filterNumList.concat(no2);
                    console.log("no2 checked"); 
                    finalSearchConditions += showConditions + "[data-channel-type = 'no2'],"; 
                  case "so2":
                    filterNumList = filterNumList.concat(so2);
                    console.log("so2 checked")
                    finalSearchConditions += showConditions + "[data-channel-type = 'so2'],"; 
                    break;
                  case "co":
                    filterNumList = filterNumList.concat(co);
                    console.log("co checked");
                    finalSearchConditions += showConditions + "[data-channel-type = 'co'],"; 
              }
            }
        });
        
        

        if (noneChecked){
          filterNumList = filterNumList.concat(allFeedNums);
          finalSearchConditions = showConditions; 
        }else{
          finalSearchConditions = finalSearchConditions.substring(0,finalSearchConditions.length - 1); 
        };

        
        //console.log($(finalSearchConditions));

        $(finalSearchConditions).each(function(){

          var currentNum = $(this).attr('id').substr($(this).attr('id').lastIndexOf('#') + 1); 

          if (filterNumList.indexOf(parseInt(currentNum)) > -1 && (showNumList.length == 0 || currentNum != showNumList[showNumList.length - 1])) {
              showNumList.push(parseInt(currentNum)); 
            }
          });


          var $allSelect = $("div[class = sensors]");
          if($allSelect){
            $allSelect.hide(); 
            console.log("Hide All");
            changeOpacity(allFeedNums, 0); 

            if (showNumList.length != 0){
              console.log("ShowNumList > 0 and show finalSearchConditions");
              $(finalSearchConditions).show();
              changeOpacity(showNumList, alpha);

              }//else{

              //   geocoder.geocode( { 'address': str}, function(results, status) {
              //     if (status == google.maps.GeocoderStatus.OK) { 
              //       var latlng = {latlng: []}
              //       console.log(results[0].geometry.viewport.northeast()); 
              //       // latlng.latlng.push(results[0].geometry.viewport);
              //       // latlng.xy = latlng.latlng;

              //       // for (var i = 0; i < latlng.latlng.length; i += 2) {
              //       //     var lat = latlng.latlng[i];
              //       //     var lon = latlng.latlng[i + 1];
              //       //     var pixel = LatLongToPixelXY(lat, lon);
              //       //     latlng.xy[i] = pixel.x;
              //       //     latlng.xy[i + 1] = pixel.y;
              //       // }
              //       // delete latlng.latlng;

              //       // var foundIndexes = []; 
              //       // for (var k = 0; k < feedLocList.index.length ; k++){
              //       //   if (Math.pow(feedLocList.xy[k*2] - latlng.xy[0],2) + Math.pow(feedLocList.xy[k*2 + 1] - latlng.xy[1],2) <= .05){
              //       //     foundIndexes.push(feedLocList.index[k]);
              //       //   }
              //       // } 

              //       // console.log(foundIndexes); 
              //       // changeOpacity(foundIndexes, alpha); 

              //     } else {
              //       console.log("Geocode was not successful for the following reason: " + status);
              //     }

              //   });

              // };
         }; 
         resetClickedList();
         drawInfoWindowLines(); 
        console.log("-------------------")
      }; 

      function drawInfoWindowLines(){
        var $mapInfoWindow = $("#infowindow");
        if ($mapInfoWindow) {
          $("#notFoundMsg").hide();
          $('hr').show(); 

          var visibleElements = $mapInfoWindow.children().filter(":visible");
          visibleElements.each(function(index, element){
              if ($(element).is('hr') && $(visibleElements).eq(index + 1).is('hr')){
                $(element).hide(); 
              };
            });

          var visibleDivs = $(visibleElements).filter(".sensors"); 
          if (visibleDivs.length == 0) {
            console.log("All Invisible.");
            $("#notFoundMsg").show();
            $("#notFoundMsg").prevAll('hr').hide(); 
            $("#notFoundMsg").nextAll('hr').hide(); 
          }else{ 
              $(visibleDivs).each(function(index, element){
                if (index==0){
                  $(this).prevAll('hr').hide(); 
                }
                if (index==$(visibleDivs).length - 1){
                  $(this).nextAll('hr').hide(); 
                }
              });
          }; 
        };
      };

      function clearFilters(){
          $('#filters [type = checkbox]').each(function(index, input){
            $(input).prop('checked', false); 
          }); 
          searchAttributes(); 
      }

      function printFoundDivs($divList){
        var string = ""; 
        $($divList).each(function(index, element){
          string += $(element).get(0).outerHTML; 
        })

        return string; 
      }

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   Timeline start  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      var multifeed = ""; 
      var dateProperties; 
      var timelineReady = false;
      var timelineQueue = []; 
      var dataProcessQueue = [];
      var pause = true;
      var onLoop = false;
      var playing = false;
      var speed = DEFAULT_SPEED;
      var timeSlices = DEFAULT_DURATION/speed*1000; 
      var duration = DEFAULT_DURATION; 
      var refreshTimer;
      var dragTimer; 
      var playInterval; 
      var prevTime; 

      function reColor(radioInput){
        resetTimeline(20, 20, 20);
        cursorInBound();
        switch(radioInput.dataset.filter){
          case "pm10":
            multifeed = "pm_10";
            break;
          case "pm25":
            multifeed = "pm_25";
            break; 
        };

        getGrapherTimeTiles(multifeed);
      }

      function clearColors(r,g,b){
        for (var i = 0, len = allFeedNums.length; i < len; i++){
          changeColor(r,g,b,allFeedNums[i]);
        }
      };

      function resetTimeline(r,g,b){
          $('#play').attr('disabled','disabled');
          pauseTimeline(); 
          playing = false; 
          timelineReady = false; 
          timelineQueue = []; 
          dataProcessQueue = [];
          multifeed = ''; 
          clearTimeout(dragTimer);
          clearTimeout(refreshTimer);
          clearColors(r,g,b);
          speed = DEFAULT_SPEED; 
          timeSlices = duration/speed*1000; 
      }

      function setSpeed(){
        if ($("#duration").val() <= 1){
          $("#duration").val(1);
        }

        duration = $("#duration").val();
        timeSlices = duration/speed*1000

        if (playing){
          pauseTimeline();
          playTimeline();
        }
      }

      function checkSpeed(){
        var now = new Date().getTime(), dt = now - prevTime; 
        if (dt > speed){
          speed = dt; 
          timeSlices = duration/speed*1000;
          console.log("Change speed: " + speed);
          pauseTimeline();
          playTimeline();
        }
      }


      function updateMultifeed(beginTime, endTime){
        timelineQueue = [];       
        if (multifeed) getTiles(beginTime, endTime, multifeed);
        
      } 

      function offsetLimitCalculator(beginTime, endTime){
        var level = Math.ceil(Math.log(Math.abs(endTime - beginTime)/512)/Math.log(2)) + 1;
        var offset = Math.floor(beginTime/(512*Math.pow(2, level))); 
        return {level: level, offset: offset};
      }

      //beginTime and endTime are in Epoch
      function getTiles(beginTime, endTime, multifeedName){
        timelineReady = false; 
        dataPocessQueue = []; 
        var result = offsetLimitCalculator(beginTime, endTime); 
        var level = result.level;
        var offset = result.offset;
        var url1 = "https://esdr.cmucreatelab.org/api/v1/multifeeds/" + multifeedName + "/tiles/" + level + "." + offset;
        var url2 = "https://esdr.cmucreatelab.org/api/v1/multifeeds/" + multifeedName + "/tiles/" + level + "." + (offset + 1);
        // window.open(url);
        getData(url1, multifeedName);
        getData(url2, multifeedName);
      }

      function getGrapherTimeTiles(multifeedName){
        var beginTime = dateProperties.min; 
        var endTime = dateProperties.max;
        getTiles(beginTime, endTime, multifeedName); 
      }

      function getData(url, multifeedName){
        var dataList = [];
        var feedNums = []; 
        jQuery.getJSON(url, function(data){
          var dataSet = data.data; 

          for (var i = 0, len = dataSet.length; i < len; i++){
            var allNull = true;
            var dataArray = dataSet[i]; 
            for (var k = 1, lenth = dataArray.length; k < lenth; k++){
              if (dataArray[k] != null) allNull = false; 
            }
            if (!allNull) dataList.push(dataArray);
          }

          $(data.full_channel_names).each(function(index, name){
            feedNums.push(parseInt(name.split(".", 2)[1].split("_")[1])); 
          });

          // if (dataList.length == 0) return; 
          dataProcessQueue.push(wrapFunction(processData, this, [dataList, feedNums, multifeedName]));
          dataWorkhorse();
        }); 
      }

      function dataWorkhorse(){
        if (dataProcessQueue.length == 2){
          while (dataProcessQueue.length){
            dataProcessQueue[0](); 
            dataProcessQueue.shift();
          }
          checkChronological();
          timelineReady = true;
          $('#play').removeAttr('disabled');
          if (playing) playTimeline();
          showColorAtIndex(findIndexAtTime(timelineQueue, dateProperties.cursorPosition));
        }
      }

      function queuePush(element){
        var min = 0; 
        var max = timelineQueue.length - 1; 
        var guess;
        var minDifference = Number.MAX_SAFE_INTEGER;
        var answer = -1; 
        while (min <= max){
          guess = Math.floor((min + max)/2);
          var difference = element.timeStamp - timelineQueue[guess].timeStamp; 

          if (Math.abs(difference) < Number.EPSILON){
            timelineQueue[guess] = element;
            return; 
          }else if(Math.abs(difference) < Math.abs(minDifference)){
            minDifference = difference;
            answer = guess; 
          }else if (min == max){
            break;
          }

          if (difference > 0){
            min = guess + 1; 
          }else{
            max = guess - 1; 
          }
          
        } 
        if (answer == -1){
          timelineQueue.push(element); 
        }else if(answer == 0){
          if (minDifference < 0){
            timelineQueue.splice(0,0,element); 
          }else{
            timelineQueue.splice(1,0,element);
          }
        }else if(minDifference > 0){
          timelineQueue.splice(answer + 1, 0, element); 
        }else{
          timelineQueue.splice(answer - 1, 0, element); 
        }
      }

      function checkChronological(){
        var preVal = timelineQueue[0].timeStamp; 
        var checkIndex = 0; 
        while (checkIndex < timelineQueue.length){
          if (timelineQueue[checkIndex].timeStamp < preVal){
            timelineQueue.splice(checkIndex - 1, 2, timelineQueue[checkIndex], timelineQueue[checkIndex - 1]); 
            checkIndex -= 1; 
            preVal = timelineQueue[checkIndex - 1].timeStamp;
          }else{
            preVal = timelineQueue[checkIndex].timeStamp;
            checkIndex++ 
          }

        }
      }

      function wrapFunction(fn, context, params){
        return function(){
          fn.apply(context, params); 
        }
      }

      //TODO: sort chronologically the colorFunctions by timeStamp before pushing to timeline
      function processData(dataList, feedNums, multifeedName){
        switch (multifeedName){
          case "pm_10":
            for (var i = 0, len = dataList.length; i < len; i++){
              var colorFunctions = {
                  functionList: [],
                  timeStamp: dataList[i][0],
              };

              for (var k = 1, lenth = dataList[i].length; k < lenth; k++){
                 if (dataList[i][k] == null){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [20, 20, 20, feedNums[k - 1]])); 
                  }else if (dataList[i][k] <= 54){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [0, 255, 0, feedNums[k - 1]]));
                  }else if(dataList[i][k] <= 154){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [255, 255, 0, feedNums[k - 1]]));
                  }else if(dataList[i][k] <= 254){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [255, 125, 0, feedNums[k - 1]])); 
                  }else if(dataList[i][k] <= 354){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [255, 0, 0, feedNums[k - 1]])); 
                  }else
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [125, 0, 0, feedNums[k - 1]])); 
              }

              queuePush(colorFunctions); 
            }
            break; 
          case "pm_25":
            for (var i = 0, len = dataList.length; i < len; i++){
              var colorFunctions = {
                  functionList: [],
                  timeStamp: dataList[i][0],
              };

              for (var k = 1, lenth = dataList[i].length; k < lenth; k++){
                 if (dataList[i][k] == null){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [20, 20, 20, feedNums[k - 1]])); 
                  }else if (dataList[i][k] <= 12){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [0, 255, 0, feedNums[k - 1]]));
                  }else if(dataList[i][k] <= 35.4){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [255, 255, 0, feedNums[k - 1]]));
                  }else if(dataList[i][k] <= 55.4){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [255, 125, 0, feedNums[k - 1]])); 
                  }else if(dataList[i][k] <= 150.4){
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [255, 0, 0, feedNums[k - 1]])); 
                  }else
                    colorFunctions.functionList.push(wrapFunction(changeColor, this, [125, 0, 0, feedNums[k - 1]])); 
              }

              queuePush(colorFunctions); 
            }
        }
      }

      //inspiratini's from binarySearch.js
      function findIndexAtTime(list, time){
        var min = 0; 
        var max = list.length - 1; 
        var guess;
        var minDifference = Number.MAX_SAFE_INTEGER;
        var answer = -1;   

        while (min <= max){
          guess = Math.floor((min + max)/2);
          var difference = time - list[guess].timeStamp; 

          if (Math.abs(difference) < Number.EPSILON){
            return guess;
          }else if(Math.abs(difference) <= minDifference){
            minDifference = Math.abs(difference);
            answer = guess; 
          }else if (min == max){
            break;
          }

          if (difference > 0){
            min = guess + 1; 
          }else{
            max = guess - 1; 
          }
          
        } 
        return answer; 

      }

      function showColorAtIndex(index){
        if (timelineReady){
          var functionList = timelineQueue[index].functionList || []; 
          for (var i = 0, len = functionList.length; i < len; i++){
            functionList[i](); 
          }
        }
      }

      function cursorInBound(){
        if (dateProperties.cursorPosition < dateProperties.min){
            plotManager.getDateAxis().setCursorPosition(dateProperties.min); 
        }else if(dateProperties.cursorPosition > dateProperties.max){
            plotManager.getDateAxis().setCursorPosition(dateProperties.max);
        }
      }

      function playTimeline(){
        pause = false;
        playing = true;
        cursorInBound();
        clearInterval(playInterval);
        playInterval = setInterval(function(){
            prevTime = Date.now();
            playNext(dateProperties.cursorPosition)
        }, speed); 
      }

      function playNext(time){
        var timeIncrement = (dateProperties.max - dateProperties.min)/timeSlices;
         
        time += timeIncrement; 

        if (time < dateProperties.max && time <= Date.now() / 1000){
          
          if (time != dateProperties.cursorPosition + timeIncrement){
            console.log("Dragging.");
            cursorInBound();
            time = dateProperties.cursorPosition;
            pauseTimeline();
            clearTimeout(dragTimer);
            dragTimer = setTimeout(function(){
              playTimeline();
            }, 300);
          }        
          
          window.requestAnimationFrame(function(){
             plotManager.getDateAxis().setCursorPosition(time);
             checkSpeed();
          });

        }else{
          if (onLoop){
            console.log("loop.")
            if (time - timeIncrement > Date.now()/1000){
              pauseTimeline(); 
              return;
            }
            plotManager.getDateAxis().setCursorPosition(dateProperties.min - timeIncrement); 
          }else{
            console.log('Timeline Done'); 
            pauseTimeline();
            playing = false; 
            plotManager.getDateAxis().setCursorPosition(dateProperties.min);     
            return; 
          }
        }
      }

      function pauseTimeline(){
        pause = true;
        clearInterval(playInterval);
      }

      function toggleLoop(){
        onLoop = !onLoop; 
        console.log("onLoop is " + onLoop);
      }

      function togglePlayPause(){
        if(pause){
          playTimeline();
        }else{
          pauseTimeline();
          playing = false;
        }
      }


      $(init);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   WebGL START   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      var map;
      var geocoder;
      var canvasLayer;
      var gl;
      var pixelsToWebGLMatrix = new Float32Array(16);
      var mapMatrix = new Float32Array(16);
      var currentIndex, minIndex, maxIndex;

      function changeColor(r, g, b, feedNum){

        var listIndex = $.inArray(feedNum, feedLocList.index); 

        feedLocList.color[listIndex * 4 + 0] = r/255; 
        feedLocList.color[listIndex * 4 + 1] = g/255; 
        feedLocList.color[listIndex * 4 + 2] = b/255; 

        if(!!gl){
          gl.bindBuffer(gl.ARRAY_BUFFER, feedLocList.colorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, feedLocList.color, gl.STATIC_DRAW);

          // enable the 'aColor' attribute in the shader to receive buffer
          gl.enableVertexAttribArray(gl.getAttribLocation(feedLocList.program, 'aColor'));

          // tell webgl how buffer is laid out 
          gl.vertexAttribPointer(gl.getAttribLocation(feedLocList.program, 'aColor'), 4, gl.FLOAT, false, 0, 0);
        }

      }

      function resetClickedList(){
        for (var i = 0, len = clickedNumList.length; i < len; i++){
          if (showNumList.indexOf(clickedNumList[i]) == -1) {
            clickedNumList.splice(i, 1); 
          }; 
        };
        changeOpacity(showNumList, alpha);
        changeOpacity(clickedNumList, 1);
      }

      function changeOpacity(feedNumArray, alpha){

        $(feedNumArray).each(function(index, feedNum){

          var listIndex = $.inArray(feedNum, feedLocList.index); 

          feedLocList.color[listIndex * 4 + 3] = alpha; 

        })

        if(!!gl){gl.bindBuffer(gl.ARRAY_BUFFER, feedLocList.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, feedLocList.color, gl.STATIC_DRAW);

        // enable the 'aColor' attribute in the shader to receive buffer
        gl.enableVertexAttribArray(gl.getAttribLocation(feedLocList.program, 'aColor'));

        // tell webgl how buffer is laid out 
        gl.vertexAttribPointer(gl.getAttribLocation(feedLocList.program, 'aColor'), 4, gl.FLOAT, false, 0, 0);}

      }

      function initializeMap() {
            var myStyle = [
                            {
                              "featureType": "poi",
                              "elementType": "labels.text",
                              "stylers": [
                                { "visibility": "off" }
                              ]
                            },
                            {
                              "featureType": "road",
                              "elementType": "labels.icon",
                              "stylers": [
                                { "visibility": "off" }
                              ]
                            },{
                                "featureType": "road",
                                "elementType": "geometry.stroke",
                                "stylers": [
                                  { "visibility": "off" }
                                ]
                              },{
                                "featureType": "road.highway",
                                "elementType": "geometry.fill",
                                "stylers": [
                                  { "color": "#bbbbbb" }
                                ]
                              },{
                                "featureType": "road"  },{
                                "featureType": "road",
                                "elementType": "labels.text.fill",
                                "stylers": [
                                  { "color": "#888888" }
                                ]
                              },{
                                "featureType": "administrative",
                                "elementType": "labels.text.fill",
                                "stylers": [
                                  { "color": "#606060" }
                                ]
                              }
                          ]

           var mapOptions = {
            //start at middle of US
            zoom: 4,
            center: new google.maps.LatLng(39.3, -95.8),
            styles: myStyle, 

            // start in Pittsburgh 
            // zoom: 13,
            // center: new google.maps.LatLng(40.442493, -79.942553),
            // styles: myStyle, 

         };
         
         map = new google.maps.Map(document.getElementById('map-div'),
            mapOptions);

         geocoder = new google.maps.Geocoder();

      }

      google.maps.event.addDomListener(window, 'load', initializeMap); 

      function drawFrame() {
        gl.enable(gl.BLEND);
        gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Compute WebGL transform from world xy coords to screen
        // copy pixel->webgl matrix
        mapMatrix.set(pixelsToWebGLMatrix);

        var scale = canvasLayer.getMapScale();
        scaleMatrix(mapMatrix, scale, scale);

        var translation = canvasLayer.getMapTranslation();
        translateMatrix(mapMatrix, translation.x, translation.y);

        // Erase frame
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Compute point diameter, in pixels, based on zoom level

        // map.zoom is approx 4 at country level
        var countryPointSizePixels = 7;

        // map.zoom is approx 18 at block level
        var blockPointSizePixels = 40;

        var pointSize = .75 * countryPointSizePixels * Math.pow(blockPointSizePixels / countryPointSizePixels, (map.zoom - 4) / (18 - 4));

        currentPointSize = pointSize; 

        var color = [0, 0, 255, alpha];

        var hardFraction = .95;  

        var count = feedLocList.index.length;

        drawPoints(gl, mapMatrix, feedLocList, 0, count, 
                   {color: color, pointSize: pointSize, hardFraction: hardFraction}); 
      }

      //for implementation of WebGL
      function initWebGL() {
        // initialize the canvasLayer
        var canvasLayerOptions = {
          map: map,
          resizeHandler: resize,
          animate: true,
          updateHandler: drawFrame
        };
        canvasLayer = new CanvasLayer(canvasLayerOptions);

        window.addEventListener('resize', function(){ 
          google.maps.event.trigger(map, 'resize'); 
          if ($('#channels').width() == 250){
            $('#map-div').css('left', 250); 
            $('#charts').css('left', 250); 
            $('#tool-bar').css('left', 250); 
          }else{
            $('#map-div').css('left', "20%");
            $('#charts').css('left', "20%"); 
            $('#tool-bar').css('left', "20%"); 
          }
        }, false);

        // initialize WebGL
        gl = canvasLayer.canvas.getContext('experimental-webgl');
        return !!gl;
      }

      function resize() {
        var w = canvasLayer.canvas.width;
        var h = canvasLayer.canvas.height;

        // Extend viewport to entire canvas
        gl.viewport(0, 0, w, h);

        // Map canvas pixel coordinates to WebGL coordinates
        pixelsToWebGLMatrix.set([2/w, 0,   0, 0,
                                 0,  -2/h, 0, 0,
                                 0,   0,   1, 0,
                                -1,   1,   0, 1]);
      }

      //When ready to draw points 
      function initializeWebGL(){

         if (!initWebGL()) {
             $('#map-div').append('<div align="center" style="position: absolute; z-index:1000000; margin:50px; padding:10px; border-color:black; border-style:solid; border-width:1px;ground-color:white; font-size:20px"><b>WebGL required</b><br>Please try using a browser that supports WebGL,<br>such as Chrome, Firefox, or Internet Explorer 11.</div>');
           }9

          // Convert from latlng to xy for map, and set up shader programs
         prepareSeries(gl, feedLocList);

         currentIndex = minIndex = feedLocList.index[0];
         maxIndex = feedLocList.index[feedLocList.index.length - 1];

         var infoWindow; 
         google.maps.event.addListener(map, 'click', function(event) {
                var finalDiv = $('<div id="infowindow"><div id="notFoundMsg" style="display:none;">No channels found based on search criteria.</div></div>'); 
                var finalInput = $('<div></div>'); 
                var sectionBreak = $('<hr>');
                var meanLat = 0; 
                var meanLng = 0; 
                var maxDistInPixels = currentPointSize/2;

                clickedNumList = []; 
          
                var eltList = findClosestElements(gl, mapMatrix, feedLocList, event.pixel, maxDistInPixels);
                var inputNodes = null; 
                var count = 0;
                var visible = false; 
                for (var i = 0; i < eltList.length; i++){
                   if (feedLocList.color[eltList[i].i * 4 + 3] != 0) {
                    count++; 
                    visible = true; 

                    clickedNumList.push(feedLocList.index[eltList[i].i]); 
                    
                    var clickedNode = $("#channels div[id $= '#" + feedLocList.index[eltList[i].i] + "']");
                    inputNodes = $(clickedNode).children().children().filter('input');

                    $(finalInput).append(inputNodes.clone()); 

                    if(i > 0 && i < eltList.length)$(finalDiv).append(sectionBreak.clone());
                    $(finalDiv).append(clickedNode.clone()); 
                    $('input[name="' + $(this).attr('name') + '"]').prop('checked', $(this).prop('checked'));
                    
                    meanLat += eltList[i].lat; 
                    meanLng += eltList[i].lng; 
                  }   
              }
              if (count != 0){
                meanLat = meanLat/count; 
                meanLng = meanLng/count; 
              }
              
              if (eltList.length != 0 && visible){
                  if (infoWindow){
                    infoWindow.close();
                    changeOpacity(showNumList, alpha); 
                  };

                 infoWindow = new google.maps.InfoWindow(
                      {content: printFoundDivs(finalDiv), 
                      position: new google.maps.LatLng(meanLat, meanLng)});
                  infoWindow.open(map);

                  changeOpacity(clickedNumList, 1);

                  google.maps.event.addListener(infoWindow, 'domready', function() {
                    $(finalInput).children().each(function (index, inputs){
                      $('input[name="' + $(this).attr('name') + '"]').prop('checked', $(this).prop('checked'));
                    }); 
                    drawInfoWindowLines();
                  });

                  google.maps.event.addListener(infoWindow,'closeclick',function(){
                    changeOpacity(showNumList, alpha);
                    clickedNumList = []; 
                  });
              };
         });

          google.maps.event.addListener(map, 'mousemove', function(event) {
                var maxDistInPixels = currentPointSize/2;
                var eltList = findClosestElements(gl, mapMatrix, feedLocList, event.pixel, maxDistInPixels);
                changeOpacity(showNumList, alpha);
                changeOpacity(clickedNumList, 1);
                for (var i = 0; i < eltList.length; i++){
                    if (feedLocList.color[eltList[i].i * 4 + 3] != 0) {
                      map.setOptions({ draggableCursor: 'default' });
                      changeOpacity([feedLocList.index[eltList[i].i]], 1); 
                    } 
                }

                if (eltList.length == 0){
                    map.setOptions({ draggableCursor: null });
                }
          });


      }

</script>

</script>

    <script id="pointVertexShader" type="x-shader/x-vertex">
      attribute vec4 worldCoord;
      attribute float aPointSize;
      attribute vec4 aColor; 

      varying vec4 vColor; 

      uniform mat4 mapMatrix;

      void main() {
        // transform world coordinate by matrix uniform variable
        gl_Position = mapMatrix * worldCoord;

        // a constant size for points, regardless of zoom level
        gl_PointSize = aPointSize;

        vColor = aColor; 
      }
    </script>
    <script id="pointFragmentShader" type="x-shader/x-fragment">
      precision mediump float;
      uniform vec4 color;
      varying vec4 vColor; 

      uniform float hardFraction;

      // Circle of diameter 0.5, composed of a "hard" (alpha=1) center of radius 0.5 * hardFraction,
      // then transitioning to alpha=0 at diameter 0.5
      void main() {
        float dist = length(gl_PointCoord.xy - vec2(.5, .5));
        // TODO(rsargent):  shouldn't we just be adjusting the alpha here?  Maybe we're taking
        // advantage of the double-multiplication to get something other than linear.
        // But multiplying all the channels will break if we do something other than an additive blend.
        
        gl_FragColor = vColor * clamp((.5 - dist) / (0.5 - 0.5 * hardFraction), 0., 1.);

      }

    </script> 

</head>
<body style="width:100%; min-width: 250px; height:100%; background-color: rgba(225, 225, 225, .5)">
<form style="width: 19%; min-width: 250px">
  <input id = "search-bar" type = "search" placeholder="Search Channel Name:" style="font-size:10px; width: 100%;">
</form>
<div style="position: absolute; height: 35px; width: 20%; min-width: 250px; background-color: rgba(50,50,50,1); top: 30px; left: 0px;"></div>
<form id = "filters" style="font-size:12.5px; position: absolute; width: 20%; min-width: 250px; height: 195px; top: 30px; left: 0px; background-color: rgba(200, 200, 200, .4);">
  <fieldset style="border: none;">
   <section>
    <legend style="padding-top: 7px; padding-bottom: 15px; font-size: 14.5px; width: 100%; font-weight: bold; color: rgba(255,255,255,.9)">Pollutant Filter</legend>
      <label><input type="checkbox" name="pm25" onclick="searchAttributes()">PM2.5<br></label>
      <label><input type="checkbox" name="pm10" onclick="searchAttributes()">PM10<br></label>
      <label><input type="checkbox" name="ozone" onclick="searchAttributes()">Ozone (O<sub>3</sub>)<br></label>
      <label><input type="checkbox" name="no" onclick="searchAttributes()">Nitric Oxide (NO)<br></label>
      <label><input type="checkbox" name="no2" onclick="searchAttributes()">Nitrogen Dioxide (NO<sub>2</sub>)<br></label>
      <label><input type="checkbox" name="so2" onclick="searchAttributes()">Sulfur Dioxide (SO<sub>2</sub>)<br></label>
      <label><input type="checkbox" name="co" onclick="searchAttributes()">Carbon Monoxide (CO)<br></label>
      <input type="button" value="Clear Search Filters" onclick="clearFilters();" >
    </section>
  </fieldset>
</form>

<div style="position: absolute; height: 35px; width: 20%; min-width: 250px; background-color: rgba(50,50,50,.75); top: 225px; left: 0px; font-weight: bold;">
    <p style="vertical-align: middle; padding-left: 10px; font-size: 14.5px; line-height: 5px; color: rgba(255,255,255,.9)">Channels</p>
</div>

<div id="channels" style="width:20%; min-width: 250px; height:calc(100vh - 215px); position:absolute; left:0px; top:260px; font-size:10px; overflow-y:auto; background-color: rgba(225, 225, 225, .5);"></div>

<div id="map-div" style="width:80%; height:55%; position:absolute; left: 20%; top:0px; z-index: -1"></div>

<div id="tool-bar" style="width: 80%; height: 5%; min-height: 50px; position: absolute; left: 20%; bottom: 45%; background-color: rgba(50,50,50,.75);">
  <form id = "map-filters" style="font-size:12px; position: relative; width: 250px; transform: translateY(-50%); top:50%; float: left; margin: 0px 10px;">
    <fieldset>
      <legend style="color: white;">Color Map:</legend>
      <label style="display: inline-block; margin: 0px 5px;"><input type="radio" name="map-filter" data-filter = "pm25" onclick="reColor(this)"><span style="color: white"> PM2.5</span><br></label>
      <label style="display: inline-block; margin: 0px 5px;"><input type="radio" name="map-filter" data-filter = "pm10" onclick="reColor(this)"><span style="color: white"> PM10</span><br></label>
      <input type="reset" value="Reset Map" onclick="resetTimeline(0, 0, 255)" style="display: inline; margin: 0px 5px;">
    </fieldset>
  </form>

  <form action="" class="timeline" style="font-size:12px; position: relative; width: 325px; transform: translateY(-50%); top:50%; float: left; margin: 0px 10px;">
    <fieldset>
      <legend style="color: white;">Playback:</legend>
      <input style="display: inline-block; margin: 0px 5px;" type="button" id="play" onclick="togglePlayPause()" value="Play/Pause" disabled>
      <input style="display: inline-block; margin: 0px 5px;" type="button" id="loop" onclick="toggleLoop()" value="Loop">
      <label style="display: inline-block; margin: 0px 5px;"><span style="color:white">Duration of Loop:</span><input type="number" min = "1" id="duration" value="15" style="width: 35px; display: inline-block; margin: 0px 5px; float: right;"></label>
    </fieldset>
  </form>
</div>
<div id="charts" style="width:80%; height: 45%; position:absolute; left: 20%; bottom: 0px;">
  <div style="position:relative; height: 50px; width:100%; border-bottom:1px solid black">
      <div id="date_axis" style="position:absolute; top:0px; bottom:0px; left:0px; right:40px"></div>
  </div>

  <div id = "plots" style="position:relative; overflow-y: auto; top:0px; height:calc(45vh - 50px);"></div> 

</div>
</body>
</html>


